\documentclass[a4paper,UKenglish,numberwithinsect,cleveref,thm-restate]{lipics-v2021}
\numberwithin{equation}{section}

%\usepackage{mlmodern}

\makeatletter
\def\renewtheorem#1{%
  \expandafter\let\csname#1\endcsname\relax
  \expandafter\let\csname c@#1\endcsname\relax
  \gdef\renewtheorem@envname{#1}
  \renewtheorem@secpar
}
\def\renewtheorem@secpar{\@ifnextchar[{\renewtheorem@numberedlike}{\renewtheorem@nonumberedlike}}
\def\renewtheorem@numberedlike[#1]#2{\newtheorem{\renewtheorem@envname}[#1]{#2}}
\def\renewtheorem@nonumberedlike#1{  
\def\renewtheorem@caption{#1}
\edef\renewtheorem@nowithin{\noexpand\newtheorem{\renewtheorem@envname}{\renewtheorem@caption}}
\renewtheorem@thirdpar
}
\def\renewtheorem@thirdpar{\@ifnextchar[{\renewtheorem@within}{\renewtheorem@nowithin}}
\def\renewtheorem@within[#1]{\renewtheorem@nowithin[#1]}
\makeatother

\theoremstyle{definition}
\renewtheorem{definition}[theorem]{Definition}

\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage[all]{xy}
\usepackage{bussproofs}
\usepackage{xspace}

\usepackage{ragged2e}
\usepackage{varwidth}

% 
\usepackage[draft,noinline,margin]{fixme}
\FXRegisterAuthor{lt}{alt}{LT}
\FXRegisterAuthor{hs}{ahs}{Josh}

\input{macros.tex}
%
\theoremstyle{plain}
\newtheorem*{notation*}{Notation}

\title{Realising Intensional \SFour and \GL Modalities} 
\author{Liang-Ting Chen}%
  {Institute of Information Science, Academia Sinica, Taiwan~\url{https://l-tchen.github.io}}%
  {liang.ting.chen.tw@gmail.com}%
  {https://orcid.org/0000-0002-3250-1331}{}
\author{Hsiang-Shang Ko}%
  {Institute of Information Science, Academia Sinica, Taiwan~\url{https://josh-hs-ko.github.io}}%
  {joshko@iis.sinica.edu.tw}%
  {https://orcid.org/0000-0002-2439-1048}{}
%\author{Tsung-Ju Chiang}%
%  {Institute of Information Science, Academia Sinica, Taiwan}%
%  {tsungju@pm.me}%
%  {}{}
\authorrunning{L.-T.~Chen and H.-S.~Ko}

\Copyright{Liang-Ting Chen and Hsiang-Shang Ko}
\ccsdesc{Theory of computation~Type theory}
\keywords{Löb's theorem, provability, guarded recursion, realisability, homotopy type theory, modal type theory, metaprogramming}

\relatedversion{} %optional, e.g. full version hosted on arXiv
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{The results were formalised in Agda 2.6.2 in the guarded cubical mode, and the source code is available at \url{https://github.com/L-TChen/provability}.}

\funding{This work was supported by the Ministry of Science and Technology of Taiwan under grant MOST~109-2222-E-001-002-MY3.}

\acknowledgements{\ltnote{Alex Kavvos, Rasmus Ejlers Møgelberg, Churn-Jung Liau, Zulip@HoTT, Zulip@Agda}
\ltnote{the aid of the community effort (the cubical library, PLFA, etc.}
}

\nolinenumbers 

%\hideLIPIcs  %uncomment to remove references to LIPIcs series

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Important Topics (CIT 2016)}
\EventShortTitle{CIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}

There have been investigations into type-theoretic foundations for metaprogramming, notably Davies and Pfenning's~(2001) treatment in \SFour modal logic, where code evaluating to values of type~$A$ is given the modal type $\mathtt{Code}\,A$ ($\Box A$ in the original paper).
Recently, in his modally typed calculus iPCF, Kavvos~(2017) extended PCF with $\mathtt{Code}\,A$ and intensional recursion, understood as the deductive form of the Gödel--Löb (\GL) axiom in provability logic, but the resulting type system is logically inconsistent.
Inspired by staged computation, we observe that a term of type $\mathtt{Code}\,A$ is, in general, code to be evaluated in a later stage, whereas \SFour modal type theory is a special case that code can be evaluated in the current stage, and the two types of code should be discriminated.
Consequently, we use two separate modalities $\boxtimes$~and~$\Box$ to model \SFour and \GL respectively in a unified categorical framework while retaining logical consistency.
Following Kavvos'~(2017) novel approach to the semantics of intensionality, we interpret the two modalities in the $\PP$-category of assemblies and trackable maps.
For the \GL modality~$\Box$ in particular, we use guarded type theory to articulate what it means by a `later' stage and to model intensional recursion by guarded recursion together with Kleene's second recursion theorem.
Besides validating the \SFour and \GL axioms, our model better captures the essence of intensionality by refuting congruence and the completeness principle $A \to \Box A$ in provability logic as well as $A \to \boxtimes A$.
That is, in our model, two extensionally equal terms may not be intensionally equal, and there is no internal quoting operation.
Our results are developed in (guarded) homotopy type theory and formalised in Agda.
\end{abstract}

\section{Introduction}\label{sec:intro}

Metaprogramming is the activity of writing metaprograms that manipulate program code.
Executing a metaprogram can result in another program to be executed, and these successive executions are abstractly referred to as computation \emph{stages}.
A particular form of metaprogramming is \emph{staged computation}, where fragments of a program are \emph{internally} marked to be evaluated in multiple stages, so that the program can be partially evaluated to produce more efficient code.
The stratification of computation stages forms possible worlds and can be ideally reasoned about by modal logic.
Therefore, there have been investigations into type-theoretic foundations for staged computation with modalities~\cite{Davies2017,Davies2001b,Kavvos2017a,Nanevski2008}, which have influenced the design of practical implementations~\cite{Kiselyov2014,Sheard2002,Taha2000} to varying degrees.
\ltnote{cite Typed Template Haskell?}

Let $\mathtt{Code}\,A$ denote the type of code that evaluates to values of type~$A$ in a next stage.
In Davies and Pfenning's analysis of staged computation~\cite{Davies2001b}, $\mathtt{Code}$ corresponds to the \SFour modality~$\boxtimes$.
More specifically, the (\textbf{4}) axiom $\boxtimes A \to {\boxtimes} {\boxtimes} A$ corresponds to the use of code in the stage after the next, so code can be shared across all stages;
the (\textbf{T}) axiom $\boxtimes A \to A$ corresponds to the \emph{evaluation} of code to its value in the same stage.
For instance, in $\lambda$-calculus, it is well-known~\cite{Barendregt1984a} that there are terms encoding Gödel code of a code and evaluating a code respectively.

Recently, Kavvos proposed a `new' construct called \emph{intensional recursion}~\cite{Kavvos2017a} for $\mathtt{Code}$ that is used to construct a value recursively from its own code (intension), extending the capabilities of metaprogramming.
In contrast to general recursion $(A \to A) \to A$, which also constructs a value recursively from its value (extension) only, intensional recursion alone does not lead to logical inconsistency.
Intensional recursion amounts to the $(\mathbf{GL})$ axiom $\Box (\Box A \to A) \to \Box A$, where $\Box$ stands for `provability' in provability logic, and its computational behaviour mirrors Kleene's second recursion theorem.
Kavvos explored the computational capabilities of a variant of PCF extended with $\mathtt{Code}$ viewed as both \SFour~and~\GL modalities.
Unfortunately, when $\mathtt{Code}$ is designed in this way, a contradiction is derivable, making it impossible to treat the type system as a logical foundation.

To make \SFour and \GL coexist in a single system while maintaining logical consistency, our approach is to keep the two modalities $\boxtimes$~and~$\Box$ separate.
Intuitively, while both modalities model code and appear similar, there are crucial differences:
In general, programs are to be evaluated in a \emph{next} stage, but \SFour is a special case where next stages include the current one, so the result of evaluating a program can be immediately used in the current stage, as witnessed by $(\mathbf{T})$.
On the other hand, a program constructed with \GL can recursively refer to its own code, which must not be evaluated within the same stage or risk non-termination computationally and inconsistency logically, so stage distinction has to be kept for \GL.

To illuminate the difference, we present in this paper a denotational semantics of two types of code---a type $\boxtimes A$ of code that can be evaluated in the current stage and a type $\Box A$ of code to be evaluated in a next stage.
To distinguish between intensions and extensions, we build upon the previous work using $\PP$-categories~\cite{Cubric1998a,Kavvos2017b}, which have an additional partial equivalence relation on morphisms that models extensional equality, while the underlying equality on morphisms models intensional equality.
We revisit elements of realisability and construct a $\PP$-category of assemblies on $\lambda$-calculus and trackable maps.
Roughly speaking, an assembly~$X$ on $\lambda$-calculus is a set $\bproj{X}$ of extensions associated with at least an intension in the form of a $\lambda$-term (the existence of such an intension is merely a property that the extension should hold), while trackable maps are pairs of a function and one of its intensions, and can be equipped with both extensional and intensional equalities (taking only the function part or both parts into account).
The denotations $\boxtimes X$ and $\Box X$ of the two types of code both consist of pairs~$(M, x)$ of an extension~$x$ and an associated intension~$M$ whose associated intensions are $\lambda$-terms that are reducible to the Gödel code~$\qquote{M}$ of~$M$.
The choice of using~$\qquote{M}$ (rather than~$M$ as chosen by Kavvos~\cite{Kavvos2017b}) as the intensions of $(M, x)$ prevents $X \to \boxtimes X$ from being natural in~$X$, that is, there is no generic internal quoting operation.
\ltnote{Ask Kavvos}
The difference between $\boxtimes X$ and $\Box X$ is, however, where extensions are from.
\begin{itemize}
    \item For $\boxtimes X$, the extension part~$x$ in $(M, x)$ coincides with the values of the set~$\bproj{X}$.
    We can then validate the \SFour axioms, for example $\boxtimes X \to X$ (natural in~$X$) by just projection.
    
    \item For $\Box X$, the extension~$x$ does not come from~$\bproj{X}$ but a different set $\laterp \bproj{X}$ whose elements denote values of~$\bproj{X}$ that are available in a next, or \emph{later}, stage.
    This set $\laterp \bproj{X}$ can be conveniently expressed in \emph{guarded type theory}, which features an internal later modality~$\laterp$ and moreover \emph{guarded recursion} $(\laterp X \to X) \to X$.
    By working in guarded typed theory, $\Box X \to X$ can no longer be validated by projection (because the value~$x$ from $(M, x)$ is available later rather than now) and is, in fact, not possible; also intensional recursion can be modelled by guarded recursion.
\end{itemize}
The above constructions do not give rise to $\PP$-functors but `exposures'~\cite{Kavvos2017b} so that congruence (the preservation of extensional equality) is not required by definition and is actually shown false.
Hence, our denotational semantics is precise enough to capture the essence of intensionality by refuting both congruence and internal quoting, which previous work~\cite{Gabbay2013,Kavvos2017b} fails to achieve.%
\ltnote{alternative word for precise}

We use homotopy type theory (HoTT)~\cite{hottbook} as our mathematical foundation, although this is mainly for convenience.
More specifically, our work is built upon the reformulated set theory and logic within HoTT, which enable us to be precise about notions such as sets and propositions, and existence with explicit witnesses versus `mere' existence (for example, within HoTT we can easily distinguish between `pairs of an extension and an intension' and `extensions associated with at least an intension').
Moreover, implementations of HoTT are readily available, so we are able to formalise and verify our constructions, for which HoTT provides essential features that some previous type theories lack, notably function extensionality: $\left(\fall{x : A} f\,x =_B g\,x\right) \to f = g$.
Indeed, our work has been formalised in Agda 2.6.2~\cite{Agda} which also supports guarded type theory in the guarded cubical mode.

%\paragraph*{Contributions}

\paragraph*{Plan of the paper}
After recalling preliminaries on untyped $\lambda$-calculus, homotopy type theory, and $\PP$-categories in \Cref{sec:preliminaries}, we present the $\PP$-category of assemblies on $\lambda$-calculus and trackable maps developed in HoTT in~\Cref{sec:assemblies} and the denotational semantics of $\boxtimes A$ and $\Box A$ in~\Cref{sec:provability}, and conclude with related and future work in~\Cref{sec:conclusion}.

\section{Preliminaries}\label{sec:preliminaries}

Most, if not all, of the materials in this section are standard, so we do not go into details but only recall what we need.

\subsection{Homotopy type theory}

In type theory, between every two inhabitants $x$~and~$y$ of a type~$A$, there is a type $x =_A y$ of proofs that $x$~and~$y$ are equal; given an equality proof $p : x =_A y$, any $z : B(x)$ can be converted to $\mathsf{transport}(p, z) : B(y)$.
Between equality proofs $p$, $q : x =_A y$ there is again a higher-dimensional equality type $p =_{x\,{=_A}\,y} q$, and so on.
Homotopy type theory (HoTT) identifies this infinite-dimensional structure of equality types as an abstract form of homotopy theory, where types are interpreted as spaces and equality proofs as paths; in particular, equality types are path spaces, and paths between paths are homotopies.
We do not make use of the full generality of HoTT, however, and work exclusively with \emph{propositions} and \emph{sets}, whose equality structure degenerates at higher dimensions.

A \emph{proposition}~$P$ is a type whose equality types (types $x =_P y$ where $x$,~$y : P$) are all inhabited---that is, all inhabitants of~$P$ are deemed equal, so all we care about~$P$ is whether it is inhabited or not.
If $P$~and~$Q$ are propositions, then their product $P \times Q$ is also a proposition.
Similarly, if a family $R(x)$ of types indexed by $x : A$ (where $A$~is any type) are all propositions, then the product $\prd{x : A} R(x)$ is also a proposition.
Logically these give us conjunction and universal quantification; therefore we sometimes write $\fall{x : A} R(x)$ in place of $\prd{x : A} R(x)$.
Function types $A \to P$ are a special case of~$\prod$, so we have implication too.
On the other hand, the disjoint sums $P + Q$ and $\sm{x : A} R(x)$ are usually not propositions.
This reflects the fact that they are constructive versions of disjunction and existential quantification.
In particular, from a proof of $\sm{x : A} R(x)$ we can project a witness $x : A$ and a proof of $R(x)$.

For any type~$A$, the \emph{propositional truncation} of~$A$ is a type~$\brck A$ for which there is an introduction rule that wraps any $a : A$ into $\bproj{a} : \brck A$, and a higher one that introduces an inhabitant of $\bproj{a} =_{\brck A} \bproj{b}$ for any $a$,~$b : A$, equating all inhabitants of~$\brck A$ and making~$\brck A$ a proposition; its recursion principle maps $\brck A$ to a proposition~$P$ provided that $A \to P$.
With truncation, we can obtain a classical version of existential quantification by defining $\exis{x : A} R(x) \defeq \brck{\sm{x : A} R(x)}$, from which we can no longer project a witness~$x$ and a proof of $R(x)$, but can only derive another proposition~$P$ provided that $\left(\sm{x : A} R(x)\right) \to P$.
Following the HoTT convention, if an existential quantification in an informal statement is truncated, we will use the words `mere' or `merely' to make it clear.

\emph{Sets} are types of~$\set$ whose equality types are all propositions, so for any two inhabitants of a set, there is at most one way for them to be equal.
It is easy to check that the types we work with in this paper are sets: types constructed from sets and the type formers $\times$, $+$, $\to$, $\prod$, and~$\sum$ are all sets, and \emph{Hedberg's theorem}~\cite[Section~7.2]{hottbook} says that if a type~$A$ has decidable equality---that is, $\prd{x, y : A} (x =_A y) + \neg(x =_A y)$---then $A$~is a set.

%We highlight the main difference between set theory and homotopy type theory.
%\ltnote{(mere) proposition, set, structure vs.\ property, $n$-types are closed under $\sum$, $\prod$-type formers, \setU, \propU, function extensionality, decidable type, $\mathsf{transport}$}

\subsection{\texorpdfstring{$\lambda$}{λ}-calculus}
For $\lambda$-calculus, we fix only notations where details can be found in the classic textbook by Barendregt~\cite{Barendregt1984a}.
Terms are defined informally by
\[
  M \defeq \mathtt{x} \mid M\,N \mid \lambda \mathtt{x}.\, M
\]
where variables $\mathtt{x}$'s are in the typewriter font.
$\Lambda$ denotes the type of terms and $\Lambda_n$ the type of terms with at most $n$ free variables.
In particular, $\Lambda_0$ is the type of \emph{closed terms}.
Our formalisation uses the de Bruijn representation, where $\alpha$-equivalent terms are identified, so the $\alpha$-equivalence~$=_\alpha$ coincides with the identity type~$=_\Lambda$ by construction.
For the presentation in this paper, the variable with index~$i$ is written $\mathtt{x}_i$\,, and given $F : \Lambda_{n+1}$ we write $F[M]$ instead of $F[M/\mathtt{x}_0]$ for the substitution for the first free variable~$\mathtt{x}_0$.
The set~$M \reduce N$ of reductions from $M$ to $N$ consists of sequences of reduction rules such as $\beta : (\lambda \mathtt{x}.\,M)\,N \onereduce M [ N / \mathtt{x} ]$.
The set $M \reduce M$ has exactly one inhabitant---the empty sequence is understood as (the proof of) the reflexivity~$\refl_\twoheadrightarrow M$, or just $\refl_\twoheadrightarrow$.
The type $\Lambda$ of terms has decidable equality as well as $M \reduce N$, so they are sets by Hedberg's theorem.

\subsubsection{Gödel encoding and the Second Recursion Theorem}\label{subsec:godel}
In $\lambda$-calculus there is a function between $\lambda$-terms
  $\qquote{\cdot} : \Lambda \to \Lambda_0$
mapping any term $M$ to a closed term $\qquote{M}$ such that $\qquote{M}$ is normal and
$M \equiv_\alpha N$ whenever $\qquote{M} \equiv_\alpha \qquote{N}$.
Moreover there are terms $\mathtt{ap}$, $\mathtt{subst} \in \Lambda_2$ and $\mathtt{quote}$, $\mathtt{eval} \in \Lambda_1$ satisfying

\begin{align*}
  \mathtt{ap}[\,\qquote{M}\,][\,\qquote{N}\,] & \reduce \qquote{M\,N}
                                                                & \mathtt{subst}[\,\qquote{F}\,][\,\qquote{N}\,] & \reduce \qquote{F[N]} \\
  \mathtt{quote}[\,\qquote{M}\,] & \reduce \qquote{\qquote{M}}         
                                                     & \mathtt{eval}[\,\qquote{M}\,] & \reduce M.
\end{align*}
This function $\qquote{\cdot}$ is called a \emph{Gödel encoding}.
By convention a quoted term $\qquote{M}$ is called a Gödel \emph{number} since the encoding function $\qquote{\cdot}$ is defined by assigning a natural number $\#M$ represented as a Church numeral $\mathbf{c}_{\#M}$ to every term~$M$.
By nature it does not have to be a number at all, so we refrain from calling $\qquote{M}$ a number. 
Instead, $\qquote{M}$ is simply called a \emph{code} of $M$. 
For details on the axiomatic characterisation of encoding, see Polonsky~\cite{Polonsky2011}.

Note that the term $\mathtt{quote}$ can only compute the code of a term $\qquote{M}$ already in a quoted form.
Indeed, no such term can compute the code of any arbitrary term.
\begin{proposition}\label{prop:no-quoting}
  There is no $\mathtt{Q} : \Lambda_1$ such that $\mathtt{Q}[M] \reduce \qquote{M}$ for any $M : \Lambda$.
\end{proposition}
\begin{proof}
  Assume such a term $\mathtt{Q}$ exists. 
  Consider $\mathtt{I} \defeq \mathtt{\lambda x.\, x}$ and $\mathtt{I}\,\mathtt{I}$ where $\mathtt{Q}[\mathtt{I}\,\mathtt{I}] \reduce \qquote{\mathtt{I}\,\mathtt{I}}$ by assumption but also $\mathtt{Q}[\mathtt{I}\,\mathtt{I}] \reduce \mathtt{Q}[\mathtt{I}]\reduce \qquote{I}$.
  Hence, by confluence and the assumption that $\qquote{M}$ is normal for any $M$, it follows that $\qquote{I\,I} \equiv_\alpha \qquote{I}$ and thus $\mathtt{I\,I} \equiv_\alpha \mathtt{I}$, a contradiction.
\end{proof}
\hsnote{revise}

Contrary to the well-known first recursion theorem, Kleene's second recursion theorem works for \emph{code} instead of values and will be used to model the \GL modality.

\begin{theorem}[Second Recursion Theorem] \label{thm:SRT}
  Every term $F : \Lambda$ has a closed term $M$ with $M \reduce F\,\qquote{M}$.
  In particular every $F : \Lambda_1$ has $\mathsf{fix}\,F : \Lambda_0$ satisfying $\mathsf{fix}\,F \reduce F[\,\qquote{\mathsf{fix}\,F}\,]$.
\end{theorem}

\subsection{\texorpdfstring{$\PP$}{P}-Categories and exposures}
Instead of ordinary categories, we work with $\PP$-categories pioneered by \v{C}ubri\'c et al.~\cite{Cubric1998a} where morphisms are equipped with an additional partial equivalence relation (PER) as another level of equality between morphisms.
Kavvos~\cite{Kavvos2017b} recently advocated its use and introduced a functor-like construct called \emph{exposure}, which does not enforce the preservation of PERs of $\PP$-categories, to manifest the essence of intensionality.
\hsnote{doesn’t really help with understanding what exposures are about}
\ltnote{better now?}

% We sketch the main idea of the works by \v{C}ubri\'c et al.\ and by Kavvos \emph{op.\ cit.} as follows.
\begin{definition}
  A \emph{partial equivalence relation} is a symmetric and transitive relation.
  A \emph{$\PP$-set} $(X, \sim_X)$ is a set $X$ with a partial equivalence relation~$\sim_X$.
  A \emph{$\PP$-function} from $(X, \sim_X)$ to $(Y, \sim_Y)$ is a function $f\colon X \to Y$ which respects the relation~$\sim$ in the sense that $f\,x \sim_Y f\,y$ whenever $x \sim_X y$.
  An element $x \in X$ is \emph{well-defined} (with respect to $\sim$) if $x \sim x$.
\end{definition}
The identity function $\idfunc[X]$ is a $\PP$-function, and the composite of two $\PP$-functions is again a $\PP$-function.
It turns out that $\PP$-sets and $\PP$-functions form a cartesian closed category, so by enriched category theory~\cite{Kelly1982} we have a notion of categories enriched by $\PP$-sets below.

\begin{definition}[{\cite[Definition~2.4]{Cubric1998a}}]
  A $\PP$-category is a category whose hom-sets are $\PP$-sets satisfying the associativity and identity laws up to~$\sim$ in the sense that 
  \begin{romanenumerate}
  \item every object~$X$ has an identity morphism $\iid_X$, 
  \item $g \circ f \sim g' \circ f'$ whenever $g\sim g'$ and $f \sim f'$,
  \item $\iid \circ f \sim f'$ and $f \circ \iid \sim f'$ whenever $f \sim f'$,
  \item $h \circ (g \circ f) \sim (h' \circ g') \circ f'$ whenever $h\sim h'$, $g \sim g'$, and $f \sim f'$.
  \end{romanenumerate}
\end{definition}

A $\PP$-category has two kinds of equality for morphisms---the underlying identity $=$ and the partial equivalence relation $\sim$, where the former is considered as the \emph{intensional equality} and the latter as the \emph{extensional equality} akin to the structure of multiple judgemental equalities in the modal type theory by Pfenning~\cite{Pfenning2002a}.
Having two different equalities $=$~and~$\sim$ reflects the fact that, for example, $\alpha$-equivalent terms are $\beta$-equivalent but not vice versa.
For categorical semantics, where terms are interpreted as morphisms, an interpretation into a $\PP$-category is able to discriminate these two kinds of equality, enabling us to model intensionality.
The usual categorical notions such as functors and initiality are up to the intensional equality~$=$\,; when we want to use the notions up to the extensional equality~$\sim$, we will add the `$\PP$-' prefix and say $\PP$-functors, $\PP$-initiality, etc.

We recall the notion of exposures, which are like $\PP$-functors but are intended to `expose' intensional differences at the extensional level: if an exposure is applied to intensionally different morphisms (which may or may not be identified extensionally), the resulting morphisms may be distinguished extensionally.
Consequently, exposures are not required to preserve the extensional equality.
Moreover, exposures are only supposed to refine the extensional equality and do not eliminate existing extensional differences---that is, they are faithful with respect to~$\sim$.
The precise definition is as follows.

\begin{definition}
  Given $\PP$-categories $\mathbf{C}$ and $\mathbf{D}$, an \emph{exposure} $Q\colon \mathbf{C} \looparrowright \mathbf{D}$ consists of \emph{(a)} a mapping $Q$ from objects $X$ of\/ $\mathbf{C}$ to objects~$QX$ of\/ $\mathbf{D}$ and \emph{(b)} from well-defined morphisms $f\colon X \to Y$ to well-defined morphisms $Qf\colon QX \to QY$ satisfying the following properties:
  \begin{romanenumerate}
    \item $Q\iid_X \sim \iid_{QX}$,
    \item $Q(g \circ f) \sim Qg \circ Qf$, and
    \item $f \sim g$ whenever $Qf \sim Qg$ for any two well-defined morphisms $f, g\colon X \to Y$. 
  \end{romanenumerate}
\end{definition}


The \emph{identity exposure} $\mathcal{I}$ maps every object or morphism to itself.
Composing two exposures in the usual way clearly gives us an exposure. 

Similarly, the notion of natural transformations is introduced for exposures which shares the same idea of the ordinary natural transformation but up to~$\sim$.
\begin{definition}
  Given exposures $P, Q\colon \mathbf{C} \looparrowright \mathbf{D}$, a \emph{natural transformation of exposures} $t\colon P \to Q$ is a family of well-defined morphisms $t_X \colon PX \to QX$ such that $Qf \circ t_X \sim t_Y \circ Pf$ for every well-defined morphism~$f\colon X \to Y$. 
\end{definition}
An \emph{evaluator} for an endo-exposure~$Q$ is a natural transformation from $Q$ to $\mathcal{I}$.

To model the \SFour modality, we may further define the notion of comonadic exposures introduced by Kavvos~\cite{Kavvos2017b} as an endo-exposure equipped with an evaluator and a natural transformation~$\delta$ from $Q$ to $Q^2$ subject to comonad laws.
In our setting, however, we observe that we would have to adopt \emph{lax} natural transformations for the comultiplication, where the naturality holds only up to $\reduce$.
We will revisit this issue in~\Cref{sec:provability}.

\section{\texorpdfstring{$\PP$}{P}-Category of assemblies on \texorpdfstring{$\lambda$}{λ}-calculus}\label{sec:assemblies}

Assemblies are used to accommodate the information of how extensions are \emph{realised by} intensions.
Accordingly an appropriate notion of morphisms between assemblies is introduced to form a $\PP$-category, laying
the technical foundation for~\Cref{sec:provability}.


\subsection{Assembly}
Traditionally, an assembly on natural numbers is a set $\bproj{X}$ with a realisability relation $\mathord{\Vdash} \subseteq \mathbb{N} \times |X|$ such that for every $x$ in $\bproj{X}$ there exists some $a$ with $a \Vdash x$, where $a$ is said to \emph{realise} $x$ or $a$ is a \emph{realiser} of $x$.
The modern notion of assemblies~\cite{Oosten2008} is often defined on a partial  combinatory algebra~$(A, \cdot)$, called \emph{PCA} for short.
For the sake of formalisation and potential applications in the design of programming languages, we base our definion on $\lambda$-calculus subject to $\alpha$-equivalence which is more akin to the one on an ordered PCA~\cite{Hofstra2003}. 

\begin{definition}\label{def:assembly}
  An \emph{assembly} $X$ on $\lambda$-calculus consists of a \emph{carrier} set $|X| : \set$ and a family ${\Vdash_X}$ of sets indexed by $\Lambda_0$ to $|X|$ as its \emph{realisability relation} such that
  \emph{(a)} there is merely a realiser $M : \Lambda_0$ of every $x : \bproj{X}$, and
  \emph{(b)} $M \Vdash_X x$ whenever $M \reduce N$ and $N \Vdash_X x$.
  That is, an assembly is a quadruple $(|X|, \Vdash_X, r_X, t_X)$ of type
  \[
    \Asm_0(\Lambda) \defeq \sm{\bproj{X} : {\setU}}{\mathord{\Vdash_X}:\Lambda_0 \to |X| \to \setU} 
      \mathsf{Respects}\left(\Vdash_X, \mathord{\twoheadrightarrow_\beta}\right)
      \times \mathsf{RightTotal}({\Vdash_X})
  \]
  where
  \begin{align}
    \mathsf{Respects}\left(\mathord{\Vdash_X}, \mathord{\twoheadrightarrow_\beta}\right) & \defeq\prd{M N : \Lambda_0}{x : |X|} \left(M \twoheadrightarrow_ \beta N\right) \to \left(N \Vdash x\right) \to \left(M \Vdash x\right) \label{eq:respect-reduction} \\      
    \mathsf{RightTotal}(\Vdash_X) & \defeq \fall{x : |X|}\exis{M : \Lambda_0} M \Vdash x
    \label{eq:right-total}
  \end{align}
\end{definition}

Our type-theoretic formulation is almost a direct translation from the set-theoretic formulation except that the realisability~$\Vdash$ is not just a relation but an indexed family of sets.
As we would like to account for intensional equality in addition to extensional equality between terms,
computationally equivalent terms should not be identified \emph{a priori}.
It turns out that formulating the interaction with reduction $\reduce$ as~\eqref{eq:respect-reduction} in line with the definition on an ordered PCA suffices to derive classic properties.
%The formulation $\left(\mathord{\Vdash_X}\;\mathsf{respects}\;\mathord{\twoheadrightarrow_\beta}\right)$ is motivated by the confluence of $\lambda$-calculus where every two $\beta$-equivalent terms $M_i$ have a confluent term $N$, i.e.\ $M_i \reduce N$ for $i = 1, 2$.
%Second, a plausible alternative to the right totality~\eqref{eq:right-total} one might expect is
%\begin{equation}\label{eq:alternative-right-totality}
%  \lprd{x : |X|} \lsm{M : \Lambda_0} M \Vdash x
%\end{equation}
%stating that each inhabitant $x : |X|$ has a choice of realisers.
%However, this is a stronger requirement than asking the mere existence of a realiser.
%With function extensionality valid in HoTT, we believe that the alternative type~\eqref{eq:alternative-right-totality} is in fact empty when $\bproj{X}$ considering Troelstra's argument~\cite{Troelstra1977}.

\begin{example}\label{ex:assembly-lambda}
  The type $\Lambda_0$ of closed terms with the reduction relation ${\reduce}$ as its realisability is an assembly $(\Lambda_0, \reduce, r_\Lambda, t_\Lambda)$ where $r_\Lambda$ and $t_\Lambda$ are given by the transitivity and the reflexivity of~$\reduce$.
\end{example}

\begin{example} \label{ex:assembly-naturals}
  Every natural number $n : \Nat$ is realised by terms that reduce to its Church numeral~$\mathtt{c}_n$.
  That is, the type $\Nat$ of natural numbers with the realisability~$\Vdash_{\Nat}$ defined by
  \[
    \left(M \Vdash_\Nat n\right) \defeq \left(M \reduce \mathtt{c}_n\right)
  \]
  is an assembly where $r_\Nat$ and $t_\Nat$ are given by the transitivity and the reflexivity of~$\reduce$.
\end{example}

\subsection{Trackable map}%

A morphism between assemblies on a PCA $(A, \cdot)$ is defined as a function~$f$ merely \emph{tracked by} some $b \in A$ in the sense that there merely exists some $b$ such that $b \cdot a \Vdash f\,x$ whenever $a \Vdash x$.
In this case, $b$ is called the \emph{tracker} of $f$.
It is noted by Kavvos~\cite{Kavvos2017b} that to bring out intensionality the tracker should be considered as part of the structure instead of a property.
\begin{definition}\label{def:trackable}
  Given assemblies $X$ and $Y$, a \emph{trackable map}~$f$ from $X$ to $Y$ consists of a function $\bproj{f}$ from $|X|$ to $|Y|$ and a term $F : \Lambda_1$ such that $F[M] \Vdash \bproj{f}\,x$ whenever $M \Vdash x$.
  In other words, the type of trackable maps is $\sum_{\bproj{f} : |X| \to |Y|} \sum_{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, \bproj{f})$ where
  \[
    \mathsf{Tracks}_{X, Y}(F, \bproj{f}) \defeq \prd{M : \Lambda_0}{x : |X|}
    \left(M \Vdash_X x\right) \to \left(F[M] \Vdash_Y \bproj{f}\, x\right).
  \]
  A \emph{merely trackable map} is an inhabitant of $\sm{\bproj{f} : |X| \to |Y|} \exis{F : \Lambda_1}\mathsf{Tracks}_{X, Y}(F, \bproj{f})$. 
\end{definition}

By definition, a trackable map~$f$ consists of not only a function~$\bproj{f}$ between carriers but also its tracker~$F$ and a transformation~$\mathfrak{f}$ for realisability.

\begin{example}[Identity]
  Every assembly $X$ has a trackable map $\iid_X \defeq (\idfunc[\bproj{X}], \mathtt{x}_0, \pr_3)$
  where
  \[
    \pr_3 \defeq \lam{M}{x}{r} r : \prd{M : \Lambda_0}{x : |X|} \left(M \Vdash_X x\right) \to \left(M  \Vdash_X x\right)
  \]
  since $\mathtt{x}_0[M]$ is judgementally equal to~$M$.
\end{example}

Now we proceed with defining the composition of trackable maps. Let $f\colon X \to Y$ and $g\colon Y \to Z$ be trackable maps.
Then, the term substitution $(G, F) \mapsto G [ F ]$ can be thought as (intensional) function composition, since $G[F[M]] =_{\Lambda_0} G[F] [M]$ holds for any term $M$.
Given any $r : M \Vdash_X x$, the inhabitant $\mathfrak{g}(\mathfrak{f}\,r)$ is of type $G[F[M]]$ and its transportation along a witness $p : G[F[M]] =_{\Lambda_0} G[F][M]$ is of type $G[F][M]$, defining a function $\lambda M\,x\,r.\, \mathsf{transport}(p, \mathfrak{g}(\mathfrak{f}\,r))$.
The above discussion amounts to defining a composition operation $(g, f) \mapsto g \circ f$.

%Then, it is not hard (but tedious and laborious) to prove that assemblies and trackable maps form an ordinary category.

%\begin{proposition}\label{prop:category-of-assemblies}
%  The type $\ASM_0(\Lambda)$ of assemblies and the family of types $\ASM_1(X, Y)$ of trackable maps form a category.
%\end{proposition}

%We may also consider reductions $F_1 \reduce F_2$ between morphisms $(f_1, F_1, \mathfrak{f}_1)$
%and $(f_2, F_2, \mathfrak{f}_2)$ as two cells since $F_1 \reduce F_2$ implies $F_1[M] \reduce F_2[M]$.
%That is, we do have a $2$-category of assemblies in the spirit of Seely's $2$-categorical model~\cite{Seely1987}.
%This line of research is out of scope of this paper, so we refrain ourselves from further discussion. 

\subsection{Extensional equality and \texorpdfstring{$\PP$}{P}-category of assemblies}

We define the partial equivalence relation $\sim$ referred to as the extensional equality on trackable maps by $f_1 \sim f_2$, that $f_1$ is said to be \emph{extensionally equal} to $f_2$, if $\bproj{f_1} = \bproj{f_2}$.
\begin{proposition}
  The type $\Asm_0$ of assemblies and the family of types $\Asm_1(X, Y)$ for any two assemblies $X$ and $Y$ with the extensional equality form a $\PP$-category~$\Asm(\Lambda)$.
\end{proposition}

We now investigate some of its basic properties.

\begin{example}[$\PP$-Terminal object]
  The unit $\top \defeq (\Unit, \Vdash_{\Unit}, r_{\Unit}, t_{\Unit})$ is $\PP$-terminal where 
  \begin{romanenumerate}
    \item $\Unit$ is the unit type,  
    \item $\Vdash_{\Unit}$ a relation defined by $M \Vdash_{\Unit} \star \defeq M \reduce \mathtt{\lambda x.\, x}$, 
    \item $r_{\Unit}: (M \reduce N) \to (N \reduce L) \to (M \reduce L)$ given by the transitivity of the reduction relation $\reduce$,
    \item and $t_{\Unit}$ the fact that the only inhabitant $\star : \Unit$ has a realiser $\mathtt{\lambda x.\, x}$ (by reflexivity).
  \end{romanenumerate}
  The finality follows from the function extensionality.
\end{example}

Every inhabitant of (the carrier of) an assembly $X$ corresponds to a merely trackable map from $\top$ to $X$.
Moreover, distinct merely trackable maps can be separated by global elements~$\top \to X$ in the ordinary category of assemblies and merely trackable maps.%
In $\Asm(\Lambda)$ where trackers are part of trackable maps, a global element has to be constructed by a pair of inhabitant $x : \bproj{X}$ and its realiser.
\begin{lemma}\label{lem:global-element}
  Let $X$ be an assembly. Then the following statements hold:
  \begin{enumerate}
    \item Every inhabitant $x_0 : \bproj{X}$ corresponds to a merely trackable map from $\top$ to $X$.
    \item Every pair of $x_0 : \bproj{X}$ and $M : \Lambda_0$ with $r_0 : M \Vdash_X x$ defines a global element of $X$, i.e.\ a trackable map from $\top$ to $X$.
  \end{enumerate}
\end{lemma}

As expected, the $\PP$-terminal object $\top$ in~$\Asm(\Lambda)$ is a $\PP$-separator in the sense that $f_1 \sim f_2$ if $f_1 \circ x \sim f_2 \circ x$ for every global element~$x$ of $X$.
This property relies on the property that the carrier $\bproj{X}$ is a set.
\begin{proposition}
  Let $f_1, f_2 : X \to Y$ be two trackable maps. Then, 
  $f_1$ is extensionally equal to $f_2$ if
  $f_1 \circ x \sim f_2 \circ x$ for every global element $x$ to $X$.
\end{proposition}
\begin{proof}[Proof sketch]
  By function extensionality, it suffices to define a trackable map $(\mathsf{c}_x, M_x, \mathfrak{M}_x)$ from $\top$ to $X$ for any inhabitant $x : \bproj{X}$, where $\mathsf{c}_x(\star) = x$.
  Then, we show that there is a path $f_1\,x = f_2\,x$ independent of the choice of $M_x$ and $\mathfrak{M}_x$, by the right totality $t_X$, the recursion principle of propositional truncation, and the assumption that $\bproj{Y}$ is a set. 
\end{proof}

\begin{corollary}
  The $\PP$-terminal object $\top$ is a $\PP$-separator in $\Asm(\Lambda)$.
\end{corollary}

%so we leave this as an exercise to the reader.
\begin{example}[Initial object]
The empty assembly $\bot$ is $\PP$-initial consisting of the empty type $\Empty$ and a relation $\Vdash_\bot : \Lambda_0 \to \Empty \to \setU$ given by the elimination rule for the empty type.
The other two components $r_\Empty$ and $t_\Empty$ are trivial.
\end{example}

In addition, one can show that $\bot$ is even a \emph{strict} $\PP$-initial object. That is, 
\begin{proposition}\label{prop:strict-initial}
  Any trackable map from some assembly $X$ to $\bot$ is a $\PP$-isomorphism. 
\end{proposition}
The strictness of $\bot$ follows easily from that for any type $X$ with a function $X \to \Empty$ one can show the equivalence $\eqv{\Empty}{X}$ in HoTT.
From the strictness of the initial object, no morphism from $\top$ to $\bot$ could exist, since $\top$ is not equivalent to $\bot$.

The construction of $\PP$-exponential $X \Rightarrow Y$ is a bit laborious.
With the definition of trackable maps, we may expect the $\PP$-exponential $X \Rightarrow Y$ to consist of trackable maps.
However, it has the type of \emph{merely} trackable maps as its carrier, since the carrier is meant to be the type of \emph{extensions} of trackable maps.
\begin{example}[$\PP$-Exponential]
  Given assemblies $X$ and $Y$, define
  \begin{align*}
    \bproj{X \Rightarrow Y} & \defeq \sm{f : |X| \to |Y|} \exis{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, f) \equiv \sm{f : |X| \to |Y|} \brck{\sm{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, f) }
  \end{align*}
  with the realisability relation 
  \[
    L \Vdash_{X \Rightarrow Y} (f, \star) \defeq \prd{M : \Lambda_0}{x : |X|} \left( M \Vdash_X x\right) \to \left(L\,M \Vdash_Y f\,x\right).
  \]
  It remains to construct $r_{X\Rightarrow Y}$ and $t_{X \Rightarrow Y}$. 
  We know that $L' \reduce L$ implies $L'\,M \reduce L\,M$, so $L'$ realises $(f, \star)$ whenever $L$ realises $(f, \star)$ and $L' \reduce L$ by $r_Y$.
  For every $(f, \star) : |X \Rightarrow Y|$, there merely exists a tracker of $f$, say $F$.
  We see that $L \defeq \left(\mathtt{\lambda x}.\,F\right)$ realises $(f, \star)$, since
  $\left(\mathtt{\lambda x}.\,F\right)\,M \onereduce F[M]$ for any $M$ and $F[M] \Vdash_Y f\,x$ whenever $M \Vdash x$.
  By applying the recursion principle of the truncated type $\brck{\sm{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, f) }$ to the second component of $(f, \star)$, there merely exists a realiser of $(f, \star)$, i.e.\ an inhabitant $t_{X \Rightarrow Y}$ for the right totality.

  The \emph{evaluation map} $(X \Rightarrow Y) \times X \xrightarrow{ev_{X, Y}} Y$ natural in $X$ and $Y$ consists of a function
  $((f, \star) , x) \mapsto f\,x$ and its tracker $(\mathtt{proj}_1 \mathtt{x}_0)\,(\mathtt{proj}_2 \mathtt{x}_0) : \Lambda_1$ where $\mathtt{x}_0$ is the free variable (thought as a pair of realisers for a function and its argument) and $\mathtt{proj}_i$ the projection function between $\lambda$-terms.

  The \emph{curried map} of a trackable function $(f, F, \mathfrak{f})$ from $Z \times X$ to $Y$ consists of
  \begin{enumerate}
    \item a function
      $f^* \defeq \lambda z.\, ((\lambda x.\, f\,(z, x)) , \star_z)$
      where by the recursion principle on the mere existence of a realiser $L_z \defeq t_Z z$ there is merely a tracker~$F[\left< L_z , \mathtt{x}_0 \right>]$ of $\lambda x.\, f\,(z, x)$;

    \item a term $F^* \defeq \lambda \mathtt{x}_0.\, F[ \left< \mathtt{x}_1, \mathtt{x}_0 \right> ]$ with 

    \item a witness $\mathfrak{f}^*$ of $\prd{L : \Lambda_0}{z : |Z|} \left(L \Vdash_Z z\right) \to \left(F^*[L] \Vdash_{X \Rightarrow Y} f\, z\right)$ by the reduction
      \[
        \left(\lambda \mathtt{x}_0, F[\left< L , \mathtt{x}_0 \right>]\right)\,M \onereduce F[\left< L , M \right>]
      \]
      and that $F$ is indeed a tracker of~$f\colon \bproj{Z \times X} \to \bproj{Y}$. 
  \end{enumerate}
  It is easy to verify all details as well as the universality.
\end{example}

It is straightforward to define the $\PP$-product of assemblies, so we omit the details from the paper.
In short, we have classic properties of the $\PP$-category $\Asm(\Lambda)$:
\begin{corollary}
  $\Asm(\Lambda)$ is a cartesian closed $\PP$-category with a strict $\PP$-initial object.
\end{corollary}
\ltnote{shall we show that $\Asm(\Lambda)$ has a natural number object? The role is replaced by~$\Lambda$ instead.}

\section{Realisability semantics for two modalities}\label{sec:provability}

In this section, we first introduce an exposure $\boxtimes\colon \Asm(\Lambda) \looparrowright \Asm(\Lambda)$ which models an \SFour modality but is subtly different from the comonadic exposure $\boxtimes_K$ introduced by Kavvos~\cite{Kavvos2017b}.
For example, $\boxtimes_K$ preserves finite products including the terminal object~$\top$, but ours does not.%
\hsnote{forward reference to \Cref{re:boxtimes-is-not}}
Most importantly, we are able to refute the existence of $X \to \boxtimes X$ being natural in~$X$, understood as a quoting function from the computational perspective, while we did not find a way to refute it with $\boxtimes_K$.
Hitherto, we have reconstructed a similar but different model~$\boxtimes$ in HoTT than the set-theoretic model~$\boxtimes_K$ based on a PCA studied by Kavvos.

Thereafter, we use an extension of cubical type theory with guarded recursion---clocked cubical type theory~\cite{Bahr2017,Kristensen2021}---and introduce an exposure-like construction $\Box$ to model the \GL modality.
We will show that $\Box$ refutes not only the completeness principle by the same argument for $\boxtimes$ but also the reflection principle $\Box X \to X$ which is valid for $\boxtimes$.
Finally, we verify the deductive form of the Gödel-Löb axiom: given a trackable map $f : \Box X \to X$ tracked by~$F$ there is an inhabitant of $\Box X$ realised by~$\qquote{\mathsf{fix}\,F}$
where $\mathsf{fix}\,F$ is the fixpoint given by the Second Recursion Theorem.

\subsection{An exposure for \texorpdfstring{\SFour}{S4} modality}
An assembly $X$ records the interplay between intensions (i.e.\ terms) and extensions, so it is possible to bring out intensions to the level of extensions by pairing $x : \bproj{X}$ with a term $M$ which realises $x$ as the carrier of $\boxtimes X$.
A pair $(M, x, r)$ with $r : M \Vdash_X x$ should be thought as the extension $x$ along with its \emph{extensional} representation~$M$.
Thus, we argue that $(M, x, r)$ shall be realised by terms which are $\beta$-equivalent to its code $\qquote{M}$ (instead of $M$ as proposed by Kavvos~\cite{Kavvos2017b}), since terms $N$ with $N \reduce \qquote{M}$ are \emph{intensional} representations of $M$.%
\hsnote{revise}
In short, the carrier and the realisability relation are defined as
\[
  \bproj{\boxtimes X} \defeq \sm{M : \Lambda_0}{x : \bproj{X}} M \Vdash x
  \quad\text{and}\quad
  \left(N \Vdash_{\boxtimes X} (M, x, r)\right) \defeq N \reduce \qquote{M}
\]
respectively.
It turns out that $\boxtimes X \defeq (\bproj{\boxtimes X}, \Vdash_{\boxtimes X}, r_{\boxtimes X}, t_{\boxtimes X})$ is indeed an assembly where $r_{\boxtimes X}$ and $t_{\boxtimes X}$ are the transitivity and the reflexivity of $\reduce$.

As for the mapping on morphisms, consider any trackable map $f$ from $X$ to $Y$ and define $\boxtimes f \defeq (\bproj{f}^\boxtimes, F^\boxtimes, \mathfrak{f}^\boxtimes)\colon \boxtimes X \to \boxtimes Y$ as follows.
First define a function from $\bproj{\boxtimes X}$ to $\bproj{\boxtimes Y}$ by
\[
  \bproj{f}^\boxtimes\colon (M, x, r) \mapsto (F[M], \bproj{f}\,x, \mathfrak{f}\,M\,x\,r).
\]
To give a tracker of $f^\boxtimes$ recall that there is a term $\mathtt{subst}$ performing term substitution on codes, so the term $F^\boxtimes \defeq \mathtt{subst}\,\qquote{F}\,\mathtt{x}$ tracks $f^\boxtimes$ because of
\begin{align*}
  \mathtt{subst}\,\qquote{F}\,N 
  \reduce \mathtt{subst}\,\qquote{F}\,\qquote{M}
  \reduce \qquote{F[M]} \Vdash_{\boxtimes Y} f^\boxtimes(M, x, r)
\end{align*}
completing the definition of $\mathfrak{f}^\boxtimes$.
In short, $\boxtimes f\defeq(\bproj{f}^\boxtimes, F^\boxtimes, \mathfrak{f}^\boxtimes)$ is a trackable map.

\begin{example} \label{ex:global-element-of-unit}
  The global element $\bigstar\colon \top \to \boxtimes \top$ corresponding to the designated inhabitant~$\star : \Unit$ is given by $(\mathtt{I}, \star, \refl_\twoheadrightarrow)$ with a realiser $\qquote{\mathtt{I}}$ using \Cref{lem:global-element}. 
  Yet, there are other global elements of $\boxtimes \top$ such as $(\mathtt{I}\,\mathtt{I}, \star, \beta)$ realised by $\qquote{\mathtt{I\,I}}$ where $\beta : \mathtt{I}\,\mathtt{I} \onereduce \mathtt{I}$ is the $\beta$-reduction rule. 
  Furthermore, the tracker of a global element might not even be a closed term but a open term. 
\end{example}

The above example shows that $\boxtimes \top$ cannot be $\PP$-isomorphic to $\top$, since there are countably many representations for $\star : \Unit$, i.e.\ inhabitants of $\bproj{\boxtimes \top}$ while there is exactly one inhabitant of $\bproj{\top} \equiv \Unit$. 
Similarly, there are trackable maps from $\boxtimes (X \times Y)$ to $\boxtimes X \times \boxtimes Y$ and vice versa, but they are not $\PP$-isomorphic.\ltnote{Is it true?}

\begin{theorem}[{\emph{cf}.~\cite[Theorem~11]{Kavvos2017b}}]\label{thm:S4-exposure}
  $\boxtimes\colon \Asm(\Lambda) \looparrowright \Asm(\Lambda)$ is an exposure of assemblies.
  Moreover, there is an evaluator $\epsilon$ for $\boxtimes$, i.e.\ a natural transformation~$\epsilon$ from $\boxtimes$ to $\mathcal{I}$.
\end{theorem}

\begin{proof}[Proof sketch]
  It is routine to prove the preservation of identities and composition.
  For example, it follows by definition that $\idfunc[\bproj{X}]^\boxtimes (M, x, r) \equiv (\mathtt{x}[M], x, \pr_3\,M\,x\,r) \equiv (M, x, r)$.

  Now we show that $\boxtimes$ reflects the extensional equality.
  Let $f$ and $g$ be trackable maps from $X$ to~$Y$.
  By assumptions that $\boxtimes f \sim \boxtimes g$ and that there are merely $M : \Lambda_0$ with $r : M \Vdash_X x$, we can apply
  the recursion principle of propositional truncation to derive 
  \[
    \boxtimes f(M, x, r) = (F[M], \bproj{f}\,x, \mathfrak{f}\,M\,x\,r)
    = (G[M], \bproj{g}\,x, \mathfrak{g}\,M\,x\,r) = \boxtimes g (M, x, r)
  \]
  since the identity type on $\boxtimes Y$ is a proposition.
  Therefore, we have $\prd{x : \bproj{X}} \bproj{f}\,x =_Y \bproj{g}\,x$.
  By function extensionality it then follows that $\left(\bproj{f} =_{\bproj{X} \to \bproj{Y}} \bproj{g}\right) \equiv f \sim g$.

  As for the evaluator $\epsilon_X\colon \boxtimes X \to X$, recall the term $\mathtt{eval}$ which evaluates a code to its representing term. 
  We simply define $\bproj{\epsilon_X}$ by $(M, x, r) \mapsto x$. 
  Then, whenever given $N : \Lambda_0$ with $N \reduce \qquote{M}$, we have $\mathtt{eval}[N] \reduce \mathtt{eval}[\qquote{M}] \reduce M$ where $M \Vdash_X x$ is witnessed by~$r$.
  That is, $\bproj{\epsilon_X}$ is tracked by~$\mathtt{eval}$.
  The naturality of $\epsilon$ follows by definition.
\end{proof}

In addition, there are functions $\bproj{\delta_X}(M, x, r) \defeq (\qquote{M}, (M, x, r), \refl_\twoheadrightarrow)$ from $\bproj{\boxtimes X}$ to $\bproj{\boxtimes \boxtimes X}$ tracked by~$\mathtt{quote}$ corresponding to the quotation of a quoted term. 
For any global element $a\colon \top \to \boxtimes X$ given by~\Cref{lem:global-element} whose tracker is indeed the quoted term~$\qquote{M}$, we can see that $\delta_X \circ a \colon \top \to \boxtimes \boxtimes X$ coincides with $\boxtimes a \circ \bigstar$ up to~$\sim$ as follows:
\[
  \bproj{\delta_X}(a(\star)) \equiv \bproj{\delta_X}(M, x, r) \equiv (\qquote{M}, (M, x, r), \refl_\twoheadrightarrow)
  = \bproj{\boxtimes a}(\mathtt{I}, \star, \refl_\twoheadrightarrow) \equiv \bproj{\boxtimes a}(\bigstar(\star)).
\]

\begin{remark} \label{re:boxtimes-is-not}
One may expect that $(\boxtimes, \epsilon, \delta)$ is comonadic in the sense that $\delta$ is also a natural transformation up to~$\sim$ satisfying comonad laws.
However, unlike the exposure $\boxtimes_K$ introduced by Kavvos~\cite[Theorem~11]{Kavvos2017a}, these maps $\delta_X$ are unfortunately \emph{not} natural in~$X$.
Indeed, for each trackable map $f\colon X \to Y$ the inhabitant 
\[
  \delta_Y (\boxtimes f(M, x, r))
  \equiv \left(\qquote{F[M]}, (F[M], f\,x, \mathfrak{f}\,M\,x\,r), \refl_{\twoheadrightarrow}\right)
\]
of type $\boxtimes \boxtimes Y$ is not equal to
\[
  \boxtimes \boxtimes f (\delta_X(M, x, r))
  \equiv (\mathsf{subst}\,\qquote{F}\,\qquote{M}, (F[M], f\,x, \mathfrak{f}\,M\,x\,r), \mathsf{subst}_{\twoheadrightarrow})
\]
in spite that their extensions $(F[M], f\,x, \mathfrak{f}\,M\,x\,r)$ are the same
where $\mathsf{subst}_{\twoheadrightarrow}$ is the witness of the reduction sequence $\mathsf{subst}\,\qquote{F}\,\qquote{M} \reduce \qquote{F[M]}$.
Nevertheless we may consider a partial order induced by the reduction relation $\mathsf{subst}\,\qquote{F}\,\qquote{M} \reduce \qquote{F[M]}$.
In detail, for inhabitants of $\boxtimes X$ define $(M, x, r) \leq (N, y, s)$ if $M \reduce N$ and $x = y$, and
accordingly define $f \leq g$ if $\bproj{f}\,x \leq \bproj{g}\,x$ for any $x$.
Then we have $\bproj{\boxtimes \boxtimes f \circ \delta_X} \leq \bproj{\delta_Y \circ \boxtimes f}$ instead.
This kind of transformations $\delta$ are called \emph{lax natural transformations}.
\end{remark}

What \Cref{re:boxtimes-is-not} implies is that the ordinary naturality is not always the right notion in the presence of intensionality, since the intension part of $\boxtimes f$ is only applied verbatim.

\begin{remark} \label{re:difference-boxtimes}
  The exposure $\boxtimes_K$ defined for assemblies on a PCA is with the carrier and the realisability relation given by
  \[
    \bproj{\boxtimes_K X} \defeq \{\,(M, x) \mid M \Vdash x \,\}
    \quad\text{and}\quad
    N \Vdash_{\boxtimes_K X} (M, x) \defeq N = M
  \]
  without the Gödel encoding. 
  It gives rise to not only an exposure but also a comonadic exposure.
  Moreover $\boxtimes_K$ preserves finite products including the terminal object $\top$.
  Preserving finite products is considered \emph{unsatisfactory} because intensions are subject to extra equations already and identified on the level of PCA.
  By taking $\lambda$-terms subject only to $\alpha$-equivalence as realisers, we are able to distinguish computationally equivalent intensions.

\hsnote{which is unsatisfactory because\ldots How does $\boxtimes$ avoid the problem?}

\end{remark}

\begin{lemma}\label{lem:no-quoting}
  The function $\eta_\Lambda \colon \Lambda_0 \to \boxtimes \Lambda_0$ defined by 
  \[
    M \mapsto (M, M, \refl_\twoheadrightarrow)
  \] 
  is not trackable by any term.
\end{lemma}
\begin{proof}
  Suppose that $\eta_\Lambda$ is tracked by~$\mathtt{Q}$.
  Being a tracker for a function from $\Lambda_0$ to $\boxtimes \Lambda_0$ means that $\mathtt{Q}[N]\reduce \qquote{M}$ whenever $N \reduce M$.
  In particular, it follows that $\mathtt{Q}[M] \reduce \qquote{M}$.
  By~\Cref{prop:no-quoting} such $\mathtt{Q}$ cannot exist.
\end{proof}

\begin{theorem}\label{thm:S4-no-quoting}
  There is no natural transformation $\eta$ from $\mathcal{I}$ to $\boxtimes$.
\end{theorem}
\begin{proof}
  Assume that such a family of trackable maps $\eta_X\colon X \to \boxtimes X$ exist.
  To prove the statement, it suffices to show that $\bproj{\eta_\Lambda}\,M_0$ is propositionally equal to $(M_0, M_0, \refl_{\twoheadrightarrow})$ so that this family $\eta$ cannot exist by \Cref{lem:no-quoting}.
  By \Cref{lem:global-element}, every closed term $M_0$ gives a trackable map $\widehat{M_0} \defeq (\lambda x.\, M_0, M_0, \mathfrak{M_0}) \colon \top \to \Lambda$ where $\mathfrak{M_0}$ is propositionally equal to the constant function with the value $\refl_{\twoheadrightarrow} : M_0 \reduce M_0$.

  Note that $\bproj{\boxtimes\widehat{M_0}}(M, x, r) = (M_0, M_0, \refl_\twoheadrightarrow)$ by definition for any inhabitant $(M, x, r)$ of type $\boxtimes \top$.
  Hence, by naturality, $\bproj{\eta_{\Lambda}}\,M_0 \equiv \bproj{\eta_{\Lambda}} \left(\bproj{\widehat{M_0}}\,\star\right) =  \bproj{\boxtimes\widehat{M_0}}\,(\bproj{\eta_\top}\,\star) = (M_0, M_0, \refl_\twoheadrightarrow)$.

\end{proof}

It remains unclear to us if the existence of a transformation $\mathcal{I} \to \boxtimes_K$ can be refuted.

\begin{remark}\label{re:S4-modality}
  Recall that the modal type theory considered by Davies and Pfenning~\cite{Davies2001b} is a dual-context simple type theory extended with an \SFour modality $\Box$, a construct $\mathtt{box}$, a $\mathtt{let}$-expression for boxed terms, and typing rules below.
\[
\begin{minipage}{.47\linewidth}
  \begin{prooftree}
    \AxiomC{$\Delta; \cdot \vdash E : A$}
    \UnaryInfC{$\Delta; \Gamma \vdash \mathtt{box}\,E:\Box A$}
  \end{prooftree}
\end{minipage}%
\begin{minipage}{0.47\linewidth}
  \begin{prooftree}
    \AxiomC{$\Delta; \Gamma \vdash E_1 : \Box A$}
    \AxiomC{$\Delta, u : A; \Gamma \vdash E_2 : B$}
  \BinaryInfC{$\Delta; \Gamma \vdash \mathtt{let}\,\mathtt{box}\, u = E_1\, \mathtt{in}\,E_2 : B$}
  \end{prooftree}
\end{minipage}
\]

Following \Cref{thm:S4-exposure,thm:S4-no-quoting}, we anticipate an interpretation of $\Box$ to justify the `omitted congruence rule' for the $\mathtt{box}$ construct~\cite[Section~2.5]{Davies2001b} and the absence of quoting function $A \to \Box A$ in their system.
\hsnote{a brief recap on the `omitted congruence rule'}
\end{remark}

\subsection{An exposure for \texorpdfstring{\GL}{GL} modality}
It is known that the Gödel-Löb axiom $\Box(\Box A \to A) \to \Box A$ is incompatible with the reflection principle $\Box A \to A$.
Indeed, let $A$ be the falsity $\bot$ for both laws. Then, we have
\[
  \Box(\Box \bot \to \bot) \to \Box \bot
  \quad\text{and}\quad
  \Box \bot \to \bot
\]
By the necessitation rule we can derive $\Box (\Box \bot \to \bot)$, and then by modus ponens we can derive $\Box \bot$ and finally $\bot$.
Therefore, by \Cref{prop:strict-initial,thm:S4-exposure}, we cannot expect the exposure $\boxtimes$ to model the Gödel-Löb axiom.
Mysteriously, the provability modality $\Box$ and the Gödel-Löb axiom are suggested to be understood also as the type of code of type~$A$ (cf.~\Cref{re:S4-modality}) and as \emph{intensional recursion} respectively from the computational perspective~\cite{Kavvos2017b}, if one is willing to give up consistency.

To untie the knot but to retain consistency and the interpretation of $\Box A$ as code of type~$A$, we refine our interpretation with a notion of \emph{computation stages}. 
Considering the counit $\epsilon_X\colon \boxtimes X \to X$, it is possible to evaluate $(M, x, r)$ because the code is already available for doing so.
And, its provability reading suggests that inhabitants of $\Box X$ are not available at the current stage but on a meta-level.
To express this idea cleanly, we work with Nakano's later modality~$\laterp$ and guarded recursion~\cite{Nakano2000}.
\hsnote{need a better story}
\ltnote{use the story given in \Cref{sec:intro}}

\subsubsection{Digression: Clocked Cubical Type Theory}
This section presents a crash course on clocked cubical type theory~\cite{Kristensen2021}, CCTT for short, which combines two extensions of dependent type theory.
The first extension is the machinery to manipulate $n$-dimensional cubes such as paths, squares, cubes, etc., allowing us to prove Voevodsky’s univalence axiom and function extensionality directly.
The second extension adds a sort $\clock$ with \emph{ticks} to support guarded recursion (also known as Löb induction) introduced by Bahr et al.~\cite{Bahr2017}.

Clocks are of a different sort $\clock$ from types, so usual type formers (such as `$\to$') are not applicable.
A clock~$\kappa$ is introduced by a clock quantification~$\forall \kappa.\, A$ into a context with rules similar to those for $\Pi$-types:
\[
  \begin{minipage}{0.47\linewidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, \kappa : \clock \vdash t : A$}
      \UnaryInfC{$\Gamma \vdash \Lambda \kappa.\, t : \forall \kappa.\, A $}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.47\linewidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash t : \forall \kappa.\, A$}
      \AxiomC{$\Gamma \vdash \kappa' : \clock $}
      \BinaryInfC{$\Gamma \vdash t[\kappa'/\kappa] : A[\kappa'/\kappa]$}
    \end{prooftree}
  \end{minipage}
\]
For convenience, a clock constant~$\kappa_0$ is presumed in the type theory.%
\hsnote{Just for convenience?}

A new type $\laterp (\alpha : \kappa). A$ on a clock~$\kappa$ is introduced as a type of suspended computations requiring a tick~$\alpha$ to compute inhabitants of~$A$.
For convenience, $\laterp (\alpha : \kappa).\,A$ is written as $\laterp^\kappa\, A$ if the tick variable is not referred to.
Formally, the rules for ticks are as follows:
\[
  \begin{minipage}{0.47\linewidth}
    \begin{prooftree}
      \AxiomC{$\Gamma, \alpha : \kappa \vdash t : A$}
      \UnaryInfC{$\Gamma \vdash \lambda (\alpha : \kappa).\, t : \laterp (\alpha : \kappa).\, A$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.47\linewidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash t : \laterp (\alpha : \kappa).\, A$}
      \AxiomC{$\Gamma, \beta : \kappa, \Gamma' \vdash$}
      \BinaryInfC{$\Gamma, \beta : \kappa , \Gamma' \vdash t[\beta] : A[\beta/\alpha]$}
    \end{prooftree}
  \end{minipage}
\]
where the elimination rule separates variables occurring before and after $\alpha$ in a context. 
The elimination rule reflects the intuition that a tick is a kind of resource.
For example, $\lambda (x : \laterp^\kappa\,\laterp^\kappa\,A).\, \lambda (\alpha : \kappa).\, x [\alpha][\alpha]$
is not typable (because $\alpha$~is wrongly used twice) but the following term is:
\[
  \Lambda \kappa.\, \lambda f.\,\lambda x.\,\lambda \alpha.\, f[\alpha]\,(x[\alpha]) : \forall \kappa.\, \laterp^\kappa(A \to B) \to \laterp^\kappa A \to \laterp^\kappa B.
\]
An inhabitant of $A$ is available in a time step given by $\mathtt{next} \defeq \Lambda \kappa.\, \lambda x.\,\lambda \alpha.\, x \colon \forall \kappa.\, A \to \laterp^\kappa A$. 

An inhabitant of $\laterp (\alpha : \kappa).\, A$ can tick on a different clock by a constant tick~$\diamond$ stated by 
\begin{prooftree}
  \AxiomC{$\Gamma, \kappa : \clock \vdash t : \laterp (\alpha : \kappa).\, A$}
  \AxiomC{$\Gamma \vdash \kappa' : \clock$}
  \BinaryInfC{$\Gamma \vdash (t[\kappa'/\kappa])[\diamond] : A[\kappa'/\kappa][\diamond/\alpha]$}
\end{prooftree}
allowing $\laterp^\kappa$ to be eliminated in a clock~$\kappa'$ different from~$\kappa$.
This tick~$\diamond$ is needed to type Atkey and McBride's~\cite{Atkey2013b} operator
  $\mathsf{force} \defeq \lambda x.\, \Lambda \kappa.\, x[\kappa][\diamond]
  : (\forall \kappa.\, \laterp^\kappa A) \to \forall \kappa.\, A$.

  Finally, every function $t : \laterp^\kappa A \to A$ has a delayed fixed point $\mathsf{dfix}\,t : A$ with a path replacing the judgemental fixed point equation (to ensure the termination of reduction semantics), called \emph{guarded recursion}.
Formally, there are two more rules
\[
  \begin{minipage}{0.47\linewidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash t : \laterp^\kappa A \to A$}
      \UnaryInfC{$\Gamma \vdash \mathsf{dfix}\,t : A$}
    \end{prooftree}
  \end{minipage}
  \begin{minipage}{0.47\linewidth}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash t : \laterp^\kappa A \to A$}
      \UnaryInfC{$\Gamma \vdash \mathsf{pfix}^\kappa t : \mathrm{Path}_A\;\left(\mathsf{dfix}\,t[\alpha]\right)\;\left(t(\mathsf{dfix}\,t)\right)$}
    \end{prooftree}
  \end{minipage}
\]
where $\mathrm{Path}_A\;x\;y$ is the type of paths from $x$ to $y$.

We now list properties needed for~\Cref{sec:GL}.
Being a proposition is irrelevant to ticks and clocks, so is being a set.
The proof is based on the fact that tick variables cannot be exchanged in a context with ordinary variables but  variables of the interval~$\mathbb{I}$.
\begin{lemma}
  If $\laterp (\alpha : \kappa).\, \mathsf{isProp}\,(A [\alpha])$ is inhabited, then so is $\mathsf{isProp}\,\laterp(\alpha: \kappa).\, A [\alpha]$. 
  Similarly, if $\laterp (\alpha : \kappa).\, \mathsf{isSet}\,(A [\alpha])$ is inhabited, then so is $\mathsf{isSet}\,\laterp(\alpha: \kappa).\, A [\alpha]$. 
\end{lemma}

The later modality distributes over a $\Sigma$-type.
It follows from that the function from $\sm{x : \laterp^\kappa A} \laterp (\alpha : \kappa).\, B\,(x[\alpha])$ to $\laterp^\kappa \left(\sm{x : A} B\,x\right)$ mapping $(x, y)$ to $\lambda (\alpha : \kappa).\, (x[\alpha], y[\alpha])$ has a quasi-inverse which entails equivalence between types.
\begin{lemma}\label{lem:later-sum}
  For $A : \UU$ and $B : A \to \UU$, there is an equivalence
  \begin{equation}\label{eq:later-sum}
    \eqv{\laterp^\kappa \sm{x : A} B\,x}{\sm{x : \laterp^\kappa A} \laterp (\alpha : \kappa).\, B (x [\alpha])}.
  \end{equation}
\end{lemma}

By univalence, guarded recursion has a particular form for $\Sigma$-types:
\begin{corollary} \label{coro:lob-induction-sum}
  Suppose that the type $\sm{x : \laterp A} \laterp (\alpha : \kappa).\,B\,(x[\alpha]) \to \sm{x : A} B\,x$ is inhabited.
  Then $\sm{x : A} B\,x$ is inhabited.
\end{corollary}

The $\mathtt{force}$ operator is an inverse of~$\mathtt{next}$ in the following sense:
\begin{lemma}
  Let $x$ be an inhabitant of $\forall \kappa.\, A$. Then, 
  $\mathtt{force}\,(\lambda \kappa.\,\lambda (\alpha : \kappa).\, x [\kappa])\,\kappa = x\,\kappa$ is inhabited for any clock $\kappa$.
\end{lemma}

It follows that a path between two inhabitants $\mathtt{next}\,x_i$ in a time step gives rise to a path now.
In other words, paths are timeless.
\begin{proposition}\label{lem:later-identity}
  Let $x$ and $y$ be inhabitants of $A$. Then, $\forall \kappa.\, \left(\mathtt{next}\,\kappa\,x_1 = \mathtt{next}\,\kappa\,x_2\right)$ implies $x_1 = x_2$.
\end{proposition}
Be aware of the scope of clock quantification.
The above proposition cannot hold within the same clock, that is, $\forall \kappa.\, \left(\mathtt{next}\,\kappa\,x_1 = \mathtt{next}\,\kappa\,x_2 \to x_1 =x_2\right)$ is not provable, since intuitively it would require us to retrieve inhabitants available later \emph{right now}.
In order to formulate the faithfulness of an exposure, the definition is adapted with a clock variable accordingly.
\begin{definition}[Clocked exposure]
  Given $\PP$-categories $\mathbf{C}$ and $\mathbf{D}$, a \emph{clocked exposure} $Q\colon \mathbf{C} \looparrowright \mathbf{D}$ consists of \emph{(a)} a mapping $Q$ for each clock $\kappa$ from objects $X$ of $\mathbf{C}$ to objects~$Q^\kappa X$ of $\mathbf{D}$ and \emph{(b)} for each clock $\kappa$ from well-defined morphisms $f\colon X \to Y$ to well-defined morphisms $Q^\kappa f\colon Q^\kappa X \to Q^\kappa Y$ satisfying following properties
  \begin{romanenumerate}
    \item $Q^\kappa \iid_X \sim \iid_{QX}$,
    \item $Q^\kappa (g \circ f) \sim Q^\kappa g \circ Q^\kappa f$, and
    \item $f \sim g$ whenever $Q^\kappa f \sim Q^\kappa g$ for any clock $\kappa$ and for any two well-defined morphisms $f, g\colon X \to Y$. 
  \end{romanenumerate}
\end{definition}
\Cref{thm:GL-exposure} gives an example of clocked exposure.

\subsubsection{Back to \texorpdfstring{\GL}{GL}} \label{sec:GL}

Now we introduce the clocked exposure $\Box^\kappa \colon \Asm(\Lambda) \to \Asm(\Lambda)$ modelling the \GL modality. 
For an assembly $X$, the carrier $\bproj{\Box^\kappa X}$ and its realisability relation $\Vdash_{\Box^\kappa}$ are defined as
\[
  \bproj{\Box^\kappa X} \defeq \sm{M : \Lambda_0}{x : {\laterp^\kappa \bproj{X}}} \laterp (\alpha : \kappa) .\, M \Vdash_X x [\alpha]
  \quad\text{and}\quad
  \left(N \Vdash_{\Box^\kappa X} (M, x, \star) \right) \defeq N \reduce \qquote{M}
\]
where $\Vdash_{\Box^\kappa X}$ is defined as the same as the comonadic exposure~$\boxtimes$.
The only difference between carriers $\bproj{\Box^\kappa X}$ and $\bproj{\boxtimes X}$ is that the type $\bproj{X}$ as what the intension denotes becomes $\laterp^\kappa \bproj{X}$.
That is, the extension $x$ of $(M, x, r)$ is available in the next stage but not earlier (within the clock $\kappa$), but the intension $M$ remains the same type.

For the obvious reason, we may drop the superscript $\kappa$ if there is no danger of confusion in the rest of this section.
Similarly, $\Box^\kappa X \defeq (\bproj{\Box^\kappa X}, \Vdash_{\Box^\kappa X}, r_{\Box^\kappa X}, t_{\Box^\kappa X})$ is an assembly where $r_{\Box^\kappa X}$ and $t_{\Box^\kappa X}$ are given by the transitivity and the reflexivity of $\reduce$. 

%\begin{notation*}
%  To avoid clumsy notations, the superscript of $\Box^\kappa$ is suppressed when appropriate.
%\end{notation*}

For any trackable map $f$ from $X$ to $Y$, also define $\Box^\kappa f$ as the same as $\boxtimes f$ with the exception of the function $\bproj{\Box^\kappa f}$ between carriers which are now involved with a later modality:
\[
  \bproj{\Box^\kappa f}(M, x, r) \defeq (F[M], \laterp^\kappa \bproj{f}\, x, \lambda \alpha.\, \mathfrak{f}\,M\,(x[\alpha])\,(r[\alpha]))
\]
where $(\laterp^\kappa f\, x)[\alpha]$ is judgementally equal to $f(x[\alpha])$, and $\laterp^\kappa \bproj{f} : \laterp^\kappa \bproj{X} \to \laterp^\kappa \bproj{Y}$ is given by the functoriality of the later modality~$\mathord{\laterp}^\kappa$.
The very same argument for $\boxtimes f$ shows that $\Box^\kappa f$ is indeed a trackable map from $\bproj{\Box^\kappa X}$ to $\bproj{\Box^\kappa Y}$.

\begin{remark*}
  By the equivalence~\eqref{eq:later-sum} and univalence, the carrier of $\Box^\kappa X$ is identical to
  $ \sm{M : \Lambda_0}\laterp^\kappa\, \sm{x : \bproj{X}} M \Vdash_X x$.
  This equivalent form is more convenient when used to reason about the delayed fixed point and will be used interchangeably with the original definition.
\end{remark*}

It is straightforward to show that $\Box^\kappa$ is a clocked exposure by \Cref{lem:later-identity}.
\begin{theorem}\label{thm:GL-exposure}
  $\Box^\kappa \colon \Asm(\Lambda) \looparrowright \Asm(\Lambda)$ is a clocked exposure.
\end{theorem}

Similar to~\Cref{thm:S4-no-quoting}, there is no family of trackable maps $\eta_X\colon X \to \Box^\kappa X$ natural in $X$ by the non-existence of a term $\mathtt{Q}$ with $\mathtt{Q}\,M \reduce \qquote{M}$ for any arbitrary term $M$.
\begin{theorem}\label{thm:GL-no-quoting}
  There is no natural transformation from $\mathcal{I}$ to $\Box^\kappa$ for any clock $\kappa$.
\end{theorem}


On the other hand, it is not possible to have a family of trackable maps $\epsilon_X$ from $\Box^\kappa X$ to $X$ natural in $X$, since the extension part of an inhabitant of $\Box^\kappa X$ can only be projected in a time step away from now.
\begin{theorem}\label{thm:GL-no-eval}
  There is no function from $\bproj{\Box^\kappa \bot}$ to $\bproj{\bot}$.
  In particular, there is no natural transformation from $\Box^\kappa$ to $\mathcal{I}$ for any $\kappa$.
\end{theorem}
\begin{proof}
  Assume $\epsilon_\bot \colon \bproj{\Box^\kappa \bot} \to \bproj{\bot}$ exists. 
  We will show that there is $\mathsf{bang}\colon \laterp \Empty \to \Empty$, so by Löb induction a contradiction $\mathsf{fix}\,\mathsf{bang} : \Empty$ is derivable.
  
  First, let $x$ be an inhabitant of $\laterp \Empty$. We construct an inhabitant $(M, x, r)$ of
  \[
    \Box^\kappa \bot \equiv \sm{M : \Lambda_0}{x : {\laterp \Empty}} \laterp (\alpha : \kappa) .\, M \Vdash_\bot x [\alpha]
  \]
  so that the function $\bproj{\epsilon_\bot}$ from $\bproj{\Box^\kappa \bot}$ to $\bproj{\bot} \equiv \Empty$ can be applied.
  For arbitrary closed term $M$, say $\mathtt{\lambda x.\, x}$, we apply the recursion principle~$\mathsf{rec}_{\Empty}$ of the empty type to~$x$ after a time step, so 
  \[
    r \defeq \lambda \alpha.\, \mathsf{rec}_{\Empty}\,(M \Vdash_\bot x[\alpha])\,x[\alpha]
  \]
  is an inhabitant of $\laterp (\alpha : \kappa) .\, M \Vdash_\bot x [\alpha]$ and thus $(M, x, r)$ is of type $\bproj{\Box^\kappa \bot}$. 
\end{proof}

The pay-off for disallowing evaluation is to be able to derive intensional recursion, i.e.\ the deductive form of the Gödel-Löb axiom from the logical perspective.

\begin{theorem}[Intensional recursion]\label{thm:GL-recursion}
  Every function $\bproj{f} \colon \bproj{\Box^\kappa X} \to \bproj{X}$ tracked by some $F$ gives rise to a global element~$f^\dagger$ of $\Box^\kappa X$ tracked by $\qquote{\mathsf{fix}\,F}$.
\end{theorem}

\begin{proof}
  Let $f$ be a trackable map from $\Box^\kappa X$ to $X$.
  We prove this statement by Löb induction on a $\Sigma$-type (\Cref{coro:lob-induction-sum}). 
  That is, assuming 
  \[
    x : \laterp \bproj{X}
    \quad\text{and}\quad
    r : \laterp (\alpha : \kappa).\, F[\,\qquote{\mathsf{fix}\,F}\,] \Vdash x [\alpha]
  \]
  we show an inhabitant of type $\bproj{X}$ realised by $\qquote{\mathsf{fix}\,F}$ as follows.
  \begin{enumerate}
    \item First,
      $\laterp(\alpha : \kappa).\left( \mathsf{fix}\,F \Vdash x [\alpha]\right)$ has an inhabitant, say $r'$, since $\mathsf{fix}\,F$ reduces to $F[\,\qquote{\mathsf{fix}\,F}\,]$. 
    \item Then, we derive an inhabitant of type $\bproj{X}$ realised by~$F[\qquote{\mathsf{fix}\,F}$ as witnessed by
      \[
        \mathfrak{f} (\refl_{\twoheadrightarrow}\qquote{\mathsf{fix}\,F}) : F[\,\qquote{\mathsf{fix}\,F}\,] \Vdash \bproj{f}(\mathsf{fix}\,F, x, r')
      \]
    since $F$ tracks $\bproj{f}$ and the set $\qquote{\mathsf{fix}\,F} \Vdash_{\Box^\kappa X} (\mathsf{fix}\,F, x, r')$ is judgementally equal to $\qquote{\mathsf{fix}\,F} \reduce \qquote{\mathsf{fix}\,F}$ which is inhabited by~$\refl_\twoheadrightarrow$.

    \item By Löb induction, $\sm{x : \laterp \bproj{X}} \laterp (\alpha : \kappa).\, F[\qquote{\mathsf{fix}\,F}\,] \Vdash x [\alpha]$ has an inhabitant~$(x_0, r_0)$.
    \item Therefore, by $\mathsf{fix}\,F \reduce F[\qquote{\mathsf{fix}\,F}]$ again, there is an inhabitant
      $(\mathsf{fix}\,F, x_0, r_0') : \Box^\kappa X$ where $r_0' : \laterp(\alpha : \kappa).\, \mathsf{fix}\,F \Vdash x_0 [\alpha]$.
  \end{enumerate}
  Evidently $(\mathsf{fix}\,F, x_0, r_0')$ is realised by $\qquote{\mathsf{fix}\,F}$ and thus by \Cref{lem:global-element} it gives rise to a global element~$f^\dagger$ of $\Box X$, concluding our proof.
\end{proof}

We may wish to prove further that the global element $f^\dagger$ is indeed a fixpoint of $f$ in the sense that $f^\dagger \sim \Box(f \circ f^\dagger) \circ \bigstar$.
This extensional equality, however, does not hold as they have different intensions ($\mathsf{fix}\,F$ versus $F[\qquote{\mathsf{fix}\,F}]$) in spite of sharing the same extension by the fixed point equality.

\section{Conclusion}\label{sec:conclusion}

\paragraph*{Related work}
\cite{Visser2019,Beklemishev2006}
\cite{Kavvos2020}
\cite{Shamkanov2014,Shamkanov2016a}
\cite{Litak2014}

\begin{itemize}
    \item  classic theory of categorical realisability is based on some partial combinatory algebra.
\end{itemize}

Compare with \cite{Kavvos2017a} in terms of the degree of intensionality
We follow the inspiring works by Kavvos in this paper to manifest the concepts of denotations, extensions, and intensions.
We have studied the $\PP$-category of assemblies on untyped $\lambda$-calculus as the foundation of categorical semantics for intensionality. 
The additional equality available in $\PP$-categories allows us to bring out intensions as morphisms which are not exposed in ordinary categories, since computationally equivalent terms are identified on the semantics side \emph{a priori} caused by the identification of \emph{denotation} with \emph{extension}.

Based on the framework established in~\Cref{sec:assemblies}, we modelled two intensional modalities $\boxtimes$ and $\Box$ satisfying the \SFour axiom and the \GL axiom respectively.
The development of the \SFour modality $\boxtimes$ refines that of Kavvos' $\boxtimes_K$ by \Cref{thm:S4-no-quoting} and as discussed in \Cref{re:difference-boxtimes}. 
As for the \GL modality, we use the clocked cubical type theory to define with a notion of computation stages.
We then show that it satisfies the deductive form of the Gödel-Löb axiom---the intensional recursion~\cite{Kavvos2017b}.
This \GL modality then partially answers the question following Theorem~5.38 in the work of Kavvos~\cite{Kavvos2020}.
Finally, we expect that typing disciplines of metaprogramming can be drawn from this line of research to guide the design of tactic programming on which many proof assistants are based.%
\hsnote{More concrete future work?}

%\paragraph*{Future work}
%First, as we have two apparently related exposures, one immediate question is how these two exposures are connected.  There is clearly a natural transformation from $\boxtimes$ to $\Box$ deferring computation to the next stage, but we do not know else much.
%The classical \SFour and \GL modalities and their connection laws are studied in Hilbert-style logic by Goris~\cite{Goris2009} with Kripke semantics in the context of provability logic.
%Accordingly, we would like to describe a type theory enriched with modalities $\boxtimes$ and $\Box$ unifying modal type theories considered by Davies and Pfenning~\cite{Davies2001b}, Pfenning~\cite{Pfenning2002a}, and by Kavvos~\cite{Kavvos2017b,Kavvos2020} while maintaining consistency.
%
%Second, inhabitants of $\Box^\kappa X$ are not accessible until the next stage. In order to arrive the next stage one needs a way to $\mathtt{force}$ them. 
%This suggests a new language construct for $\Box^\kappa X$ apart from its introduction and elimination rules considered by Kavvos~\cite{Kavvos2017a}.
%This construct may correspond to compiler-time code generation---a common form of metaprogramming during compiler-time which, to be the best of our knowledge, does not have a known denotational semantics.

%\ltnote{Third, \Cref{re:boxtimes-is-not} suggests a theory on categories enriched by \emph{partially ordered $\PP$-sets} instead}

%Finally, categories internal to clocked type theory seem worth further investigation.
%It is a natural setting when the underlying foundation is equipped with Löb induction (guarded recursion) as an abstract approach to the step-indexing technique used to reason about programming language features.
%We expect this line of research may provide a convenient framework for categorical semantics of those programming languages.
%

%If we follow the insight of Davies and Pfenning, then $\boxtimes X$ should be understood as the denotation for the type of typed code.
%As a sanity check, we may further ask the type $\mathsf{Code}$ of \emph{untyped} code and a polymorphic function from $\boxtimes A$ to $\mathsf{Code}$ forgetting what a typed code denotes. 
%This is indeed the case and the point of the following statement.
%\begin{theorem}
%
%  
%\end{theorem}

\nocite{Bauer2006}
\bibliographystyle{plainurl}% the mandatory bibstyle
\bibliography{ref}

\appendix

\end{document}

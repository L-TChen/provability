\documentclass[a4paper,UKenglish,numberwithinsect,cleveref,thm-restate]{lipics-v2021}
\numberwithin{equation}{section}

%\usepackage{mlmodern}

\makeatletter
\def\renewtheorem#1{%
  \expandafter\let\csname#1\endcsname\relax
  \expandafter\let\csname c@#1\endcsname\relax
  \gdef\renewtheorem@envname{#1}
  \renewtheorem@secpar
}
\def\renewtheorem@secpar{\@ifnextchar[{\renewtheorem@numberedlike}{\renewtheorem@nonumberedlike}}
\def\renewtheorem@numberedlike[#1]#2{\newtheorem{\renewtheorem@envname}[#1]{#2}}
\def\renewtheorem@nonumberedlike#1{  
\def\renewtheorem@caption{#1}
\edef\renewtheorem@nowithin{\noexpand\newtheorem{\renewtheorem@envname}{\renewtheorem@caption}}
\renewtheorem@thirdpar
}
\def\renewtheorem@thirdpar{\@ifnextchar[{\renewtheorem@within}{\renewtheorem@nowithin}}
\def\renewtheorem@within[#1]{\renewtheorem@nowithin[#1]}
\makeatother

\theoremstyle{definition}
\renewtheorem{definition}[theorem]{Definition}

\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{bussproofs}
\usepackage{xspace}

\usepackage{ragged2e}
\usepackage{varwidth}

% 
\usepackage[noinline,margin,draft]{fixme}
\FXRegisterAuthor{lt}{alt}{LT}
\FXRegisterAuthor{hs}{ahs}{Josh}

\input{macros.tex}
%
\theoremstyle{plain}
\newtheorem*{notation*}{Notation}

\title{Realising Intensional S4 and GL Modalities} 
\author{Liang-Ting Chen}%
  {Institute of Information Science, Academia Sinica, Taipei, Taiwan \and \url{https://l-tchen.github.io}}%
  {liang.ting.chen.tw@gmail.com}%
  {https://orcid.org/0000-0002-3250-1331}{}
\author{Hsiang-Shang Ko}%
  {Institute of Information Science, Academia Sinica, Taipei, Taiwan \and \url{https://josh-hs-ko.github.io}}%
  {joshko@iis.sinica.edu.tw}%
  {https://orcid.org/0000-0002-2439-1048}{}
\authorrunning{L.-T.~Chen and H.-S.~Ko}

\Copyright{Liang-Ting Chen and Hsiang-Shang Ko}
\ccsdesc{Theory of computation~Type theory}
\keywords{provability, guarded recursion, realisability, modal types, metaprogramming}

\relatedversion{} %optional, e.g. full version hosted on arXiv
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

\supplement{The results were formalised in Agda 2.6.2 in the guarded cubical mode, and the source code is available at \url{https://github.com/L-TChen/provability}.\ltnote{Zenodo?}}

\funding{This work was partially supported by EPSRC grant number EP/N028139/1 and supported by the Ministry of Science and Technology of Taiwan under grant MOST~109-2222-E-001-002-MY3.}

\acknowledgements{%
  We are grateful to Alex Kavvos and Tsung-Ju Chiang for insightful discussions.
  We would also like to thank Tom de Jong, Churn-Jung Liau, Rasmus Ejlers Møgelberg, Chad Nester, Anton Setzer, Andrea Vezzosi, Ren-June Wang, and Zhixuan Yang for useful exchanges.
  Finally, we thank the anonymous reviewers for their suggestions and thoughtful comments, which are encouraging to us.}


\nolinenumbers 

%\hideLIPIcs  %uncomment to remove references to LIPIcs series

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Important Topics (CIT 2016)}
\EventShortTitle{CIT 2016}
\EventAcronym{CIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

\begin{abstract}

There have been investigations into type-theoretic foundations for metaprogramming, notably Davies and Pfenning's~(2001) treatment in \SFour modal logic, where code evaluating to values of type~$A$ is given the modal type $\mathtt{Code}\,A$ ($\Box A$ in the original paper).
Recently Kavvos~(2017) extended PCF with $\mathtt{Code}\,A$ and intensional recursion, understood as the deductive form of the \GL (Gödel-Löb) axiom in provability logic, but the resulting type system is logically inconsistent.
Inspired by staged computation, we observe that a term of type $\mathtt{Code}\,A$ is, in general, code to be evaluated in a next stage, whereas \SFour modal type theory is a special case where code can be evaluated in the current stage, and the two types of code should be discriminated.
Consequently, we use two separate modalities $\boxtimes$~and~$\Box$ to model \SFour and \GL respectively in a unified categorical framework while retaining logical consistency.
Following Kavvos'~(2017) novel approach to the semantics of intensionality, we interpret the two modalities in the $\PP$-category of assemblies and trackable maps.
For the \GL modality~$\Box$ in particular, we use guarded type theory to articulate what it means by a `next' stage and to model intensional recursion by guarded recursion together with Kleene's second recursion theorem.
Besides validating the \SFour and \GL axioms, our model better captures the essence of intensionality by refuting congruence (so that two extensionally equal terms may not be intensionally equal) and internal quoting (both $A \to \Box A$ and $A \to \boxtimes A$).
Our results are developed in (guarded) homotopy type theory and formalised in \textsc{Agda}.
\end{abstract}

\section{Introduction}\label{sec:intro}

Metaprogramming is the activity of writing metaprograms that manipulate program code.
Executing a metaprogram can result in another program to be executed, and these successive executions are abstractly referred to as computation \emph{stages}.
A particular form of metaprogramming is \emph{staged computation}, where fragments of a program are \emph{internally} marked to be evaluated in multiple stages, so that the program can be partially evaluated to produce more efficient code.
The stratification of computation stages forms possible worlds and can be ideally reasoned about by modal logic.
Therefore, there have been investigations into type-theoretic foundations for staged computation with modalities~\cite{Davies2017,Davies2001b,Kavvos2021,Nanevski2008}, which have influenced the design of practical implementations~\cite{Kiselyov2014,Sheard2002,Taha2000} to varying degrees.

Let $\mathtt{Code}\,A$ denote the type of code that evaluates to values of type~$A$ in a next stage.
In Davies and Pfenning's analysis of staged computation~\cite{Davies2001b}, $\mathtt{Code}$ corresponds to the modality~$\boxtimes$ in the intuitionistic modal logic \SFour.
More specifically, the \textbf{4} axiom $\boxtimes A \to {\boxtimes} {\boxtimes} A$ corresponds to the use of code in the stage after the next, so code can be shared across all stages, a.k.a.~\emph{cross-stage persistence};
the \textbf{T} axiom $\boxtimes A \to A$ corresponds to the \emph{evaluation} of code to its value in the same stage.
For instance, in $\lambda$-calculus, it is well-known~\cite{Barendregt1984a} that there are terms encoding Gödel code of a code and evaluating a code respectively.

Recently, Kavvos proposed \emph{intensional recursion}~\cite{Kavvos2021} for $\mathtt{Code}$ to construct a value recursively from its own code (intension), extending the capabilities of metaprogramming.
Logically, intensional recursion amounts to the \GL (Gödel-Löb) axiom $\Box (\Box A \to A) \to \Box A$ for the modal logic \GL~\cite{Boolos-provability}, where $\Box A$ stands for `$A$~is provable'.
Computationally, the behaviour of the \GL axiom mirrors Kleene's second recursion theorem.
In contrast to general recursion $(A \to A) \to A$, which constructs a value recursively from its value (extension), intensional recursion alone does not lead to logical inconsistency.
Kavvos explored the computational capabilities of a variant of PCF extended with $\mathtt{Code}$ viewed as both \SFour~and~\GL modalities.
Unfortunately, when $\mathtt{Code}$ is designed in this way, the type system is inconsistent so that it cannot be treated as a logical foundation.

To make \SFour and \GL coexist in a single system while maintaining logical consistency, our approach is to keep the two modalities $\boxtimes$~and~$\Box$ separate.
Intuitively, while both modalities model code and appear similar, there are crucial differences:
In general, programs are to be evaluated in a \emph{next} stage, but \SFour is a special case where next stages include the current one, so the result of evaluating a program can be immediately used in the current stage, as witnessed by $\mathbf{T}$.
On the other hand, a program constructed with \GL can recursively refer to its own code, which must not be evaluated within the same stage or risk non-termination computationally and inconsistency logically, so stage distinction has to be kept for \GL.

To illuminate the difference, we present in this paper a denotational semantics of two types of code---a type $\boxtimes A$ of code that can be evaluated in the current stage and a type $\Box A$ of code to be evaluated in a next stage.
To distinguish between intensions and extensions, we build upon the previous work using $\PP$-categories~\cite{Cubric1998a,Kavvos2017b}, which have an additional partial equivalence relation on morphisms that models extensional equality, while the underlying equality on morphisms models intensional equality.
We revisit elements of realisability and construct a $\PP$-category of assemblies on $\lambda$-calculus.
Roughly speaking, an assembly~$X$ on $\lambda$-calculus is a set $\bproj{X}$ of extensions associated with at least an intension in the form of a $\lambda$-term (the existence of such an intension is merely a property that holds for the extension), while trackable maps are pairs of a function and one of its intensions, and can be equipped with both extensional and intensional equalities (taking only the function part or both parts into account).
The denotations $\boxtimes X$ and $\Box X$ of the two types of code both consist of pairs~$(M, x)$ of an extension~$x$ and an associated $\lambda$-term~$M$ whose associated intensions are $\lambda$-terms that are reducible to the Gödel code~$\qquote{M}$.
The choice of using~$\qquote{M}$ (rather than~$M$ as chosen by Kavvos~\cite{Kavvos2017b}) as the intensions of $(M, x)$ prevents $X \to \boxtimes X$ from having the meaning of generic quoting.
The difference between $\boxtimes X$ and $\Box X$ is what extensions are.
\begin{itemize}
    \item For $\boxtimes X$, the extension part~$x$ in $(M, x)$ coincides with the values of the set~$\bproj{X}$.
    We can then validate the \SFour axioms, for example $\boxtimes X \to X$ (natural in~$X$) by just projection.
    
    \item For $\Box X$, the extension~$x$ does not come from~$\bproj{X}$ but a different set $\laterp \bproj{X}$ whose elements denote values of~$\bproj{X}$ that are available in a next, or \emph{later}, stage.
    This set $\laterp \bproj{X}$ can be expressed directly in a \emph{guarded type theory} which features Nakano's later modality~$\laterp$ and \emph{guarded recursion}~\cite{Nakano2000}.
    By working in guarded type theory, $\Box X \to X$ can no longer be validated by projection (because~$x$ from $(M, x)$ is available later rather than now) and is actually not possible; also intensional recursion can be modelled by guarded recursion.
\end{itemize}
The above constructions do not give rise to $\PP$-functors but `exposures'~\cite{Kavvos2017b} so that congruence (the preservation of extensional equality) is not required by definition and is actually false.
Hence, by refuting both congruence and generic quoting, which previous work~\cite{Gabbay2013,Kavvos2017b} did not achieve, our denotational semantics is more intensional in the sense that it provides a finer-grained equality which allows us to distinguish computationally equivalent intensions.%

We use homotopy type theory (HoTT)~\cite{hottbook} as our metalanguage, but this is only for access to a small subset of convenient HoTT features, which in particular does not include univalence.
Specifically, our work is built upon the reformulated set theory and logic within HoTT, which enable us to be precise about notions such as sets and propositions, and existence with explicit witnesses versus `mere' existence (for example, within HoTT we can easily distinguish between `pairs of an extension and an intension' and `extensions associated with at least an intension').
Moreover, implementations of HoTT are readily available, so we are able to formalise and verify our constructions, for which HoTT provides essential features that some other type theories lack, notably function extensionality: $\left(\fall{x : A} f\,x =_B g\,x\right) \to f =_{A \to B} g$.
Indeed, our work has been formalised in \textsc{Agda}~\cite{Agda}, which implements HoTT and guarded type theory respectively in the forms of cubical type theory~\cite{Cohen2015, Vezzosi-Cubical-Agda} and ticked cubical type theory~\cite{Veltri2020} with clock quantification~\cite{Kristensen2021}; we do not use cubical arguments, however.

%\paragraph*{Contributions}

\paragraph*{Plan of the paper}
After recalling preliminaries on homotopy type theory, untyped $\lambda$-calculus, and $\PP$-categories in \cref{sec:preliminaries}, we present the $\PP$-category of assemblies on $\lambda$-calculus and trackable maps developed in HoTT in~\cref{sec:assemblies} and the denotational semantics of $\boxtimes A$ and $\Box A$ in~\cref{sec:S4-modality,sec:GL-modality} respectively, and discuss related work in \Cref{sec:related-work} and future work in~\cref{sec:conclusion}.

\section{Preliminaries}\label{sec:preliminaries}
Most, if not all, of the materials in this section are standard, so we do not go into details.

\subsection{Homotopy type theory}
In type theory, between every two inhabitants $x$~and~$y$ of a type~$A$, there is a type $\id[A]{x}{y}$ of proofs that $x$~and~$y$ are (propositionally) equal; given an equality proof $p : x =_A y$, any $z : B(x)$ can be converted to $\mathsf{transport}(p, z) : B(y)$.
Between equality proofs $p$, $q : \id[A]{x}{y}$ there is again a higher-dimensional equality type $\id[{\id[A]{x}{y}}]{p}{q}$, and so on.
Homotopy type theory (HoTT) identifies this infinite-dimensional structure of equality types as an abstract form of homotopy theory, where types are interpreted as spaces and equality proofs as paths; in particular, equality types are path spaces, and paths between paths are homotopies.
We do not make use of the full generality of HoTT, however, and work exclusively with \emph{propositions} and \emph{sets}, whose equality structure degenerates at higher dimensions.

A \emph{proposition}~$P$ is a type whose equality types $\id[P]{x}{y}$, for $x$ and $y : P$, are all inhabited---all inhabitants of~$P$ are deemed equal, so all we care about~$P$ is whether it is inhabited, not its specific inhabitants.
Hence, we will simply write~$\star$ when referring to an inhabitant of any proposition.
If $P$~and~$Q$ are propositions, then their product $P \times Q$ is also a proposition.
Similarly, if a family $R(x)$ of types indexed by $x : A$ (where $A$~is any type) are all propositions, then the product $\prd{x : A} R(x)$ is also a proposition.
Logically these give us conjunction and universal quantification; therefore we sometimes write $\fall{x : A} R(x)$ in place of $\prd{x : A} R(x)$.
Function types $A \to P$ are a special case of~$\prod$, so we have implication too.
On the other hand, the disjoint sums $P + Q$ and $\sm{x : A} R(x)$ are usually not propositions.
This reflects the fact that they are constructive disjunction and existential quantification.
In particular, from a proof of $\sm{x : A} R(x)$ we can project a witness $x : A$ and a proof of $R(x)$.

For any type~$A$, the \emph{propositional truncation} of~$A$ is a type~$\brck A$ for which there is an introduction rule that wraps any $a : A$ into $\bproj{a} : \brck A$, and a higher one that introduces an inhabitant of $\bproj{a} =_{\brck A} \bproj{b}$ for any $a$,~$b : A$, equating all inhabitants of~$\brck A$ and making~$\brck A$ a proposition; its recursion principle maps $\brck A$ to a proposition~$P$ provided that $A \to P$.
With truncation, we can obtain a classical version of existential quantification by defining $\exis{x : A} R(x) \defeq \brck{\sm{x : A} R(x)}$, from which we can no longer project a witness~$x$ and a proof of $R(x)$, but can only derive another proposition~$P$ provided that $\left(\sm{x : A} R(x)\right) \to P$.
Following the HoTT convention, if an existential quantification in an informal statement is truncated, we will use the words `mere' or `merely' to make it clear.

\emph{Sets} are types whose equality types are all propositions, so for any two inhabitants of a set, there is at most one way for them to be equal.
It is easy to check that the types we work with in this paper are sets: types constructed from sets and the type formers $\times$, $+$, $\to$, $\prod$, and~$\sum$ are all sets, and \emph{Hedberg's theorem} is useful for proving that a base type~$A$ is a set---if $A$~has decidable equality, that is, $\prd{x, y : A} (x =_A y) + \neg(x =_A y)$, then $A$~is a set (which we will write as $A : \set$ for short).

%We highlight the main difference between set theory and homotopy type theory.
%\ltnote{(mere) proposition, set, structure vs.\ property, $n$-types are closed under $\sum$, $\prod$-type formers, \setU, \propU, function extensionality, decidable type, $\mathsf{transport}$}

\subsection{\texorpdfstring{$\lambda$}{λ}-calculus, Gödel encoding, and the second recursion theorem}\label{sec:lambda}

For $\lambda$-calculus we only fix notations.
The details are left to, for example, the classic textbook by Barendregt~\cite{Barendregt1984a}.
Terms are defined informally by
\[
  M \defeq \mathtt{x} \mid M\,N \mid \lam{\mathtt{x}}M
\]
where variables $\mathtt{x}$'s are in the typewriter font.
$\Lambda$ denotes the type of terms and $\Lambda_n$ the type of terms with at most $n$ free variables.
In particular, $\Lambda_0$ is the type of \emph{closed terms}.
Our formalisation uses the de Bruijn representation, so the $\alpha$-equivalence~$=_\alpha$ coincides with the equality type~$=_\Lambda$ by construction.
For the presentation in this paper, the variable with index~$i$ is written $\mathtt{x}_i$\,, and given $F : \Lambda_{n+1}$ we write $F[M]$ instead of $F[M/\mathtt{x}_0]$ for the substitution for the first free variable~$\mathtt{x}_0$.
The type~$M \reduce N$ of reductions from $M$ to $N$ consists of sequences of reduction rules such as $\beta : (\lam{\mathtt{x}}M)\,N \onereduce M [ N / \mathtt{x} ]$; as a special case, the type $M \reduce M$ has exactly one inhabitant $\refl_\twoheadrightarrow M$, or just $\refl_\twoheadrightarrow$, which can be understood as either the empty sequence or (the proof of) the reflexivity of reduction.
The types $\Lambda$ and $M \reduce N$ have decidable equality, so they are sets by Hedberg's theorem.

There is a function between $\lambda$-terms $\qquote{\cdot} : \Lambda \to \Lambda_0$ such that $\qquote{M}$ is normal and
$M =_\alpha N$ whenever $\qquote{M} =_\alpha \qquote{N}$.
Moreover, there are $\mathtt{ap}$, $\mathtt{subst} \in \Lambda_2$ and $\mathtt{quote}$, $\mathtt{eval} \in \Lambda_1$ satisfying
\begin{align*}
  \mathtt{ap}[\,\qquote{M}\,][\,\qquote{N}\,] & \reduce \qquote{M\,N}
                                                                & \mathtt{subst}[\,\qquote{F}\,][\,\qquote{N}\,] & \reduce \qquote{F[N]} \\
  \mathtt{quote}[\,\qquote{M}\,] & \reduce \qquote{\qquote{M}}         
                                                     & \mathtt{eval}[\,\qquote{M}\,] & \reduce M.
\end{align*}
This function $\qquote{\cdot}$ is called a \emph{Gödel encoding}.
Traditionally, a quoted term $\qquote{M}$ is called a Gödel \emph{number} since the encoding $\qquote{\cdot}$ assigns to every term~$M$ a Church numeral $\mathbf{c}_{\#M}$.
An encoding needs not be a number at all, however, so we simply call $\qquote{M}$ a \emph{code} of~$M$ rather than a number.
For details on the axiomatic characterisation of encoding, see Polonsky~\cite{Polonsky2011}.

Note that the term $\mathtt{quote}$ can only compute the code of a term $\qquote{M}$ which is already in quoted form.
Indeed, no term can compute the code of any arbitrary closed term.
\begin{proposition}\label{prop:no-quoting}
  There is no $\mathtt{Q} : \Lambda_1$ such that $\mathtt{Q}[M] \reduce \qquote{M}$ for all $M : \Lambda_0$.
\end{proposition}
%\begin{proof}
%  Assume such a term $\mathtt{Q}$ exists. 
%  Consider $\mathtt{I} \defeq \mathtt{\lambda x.\, x}$ and $\mathtt{I}\,\mathtt{I}$ where $\mathtt{Q}[\mathtt{I}\,\mathtt{I}] \reduce \qquote{\mathtt{I}\,\mathtt{I}}$ by assumption but also $\mathtt{Q}[\mathtt{I}\,\mathtt{I}] \reduce \mathtt{Q}[\mathtt{I}]\reduce \qquote{I}$.
%  Hence, by confluence and the assumption that $\qquote{M}$ is normal for any $M$, it follows that $\qquote{I\,I} \equiv_\alpha \qquote{I}$ and thus $\mathtt{I\,I} \equiv_\alpha \mathtt{I}$, a contradiction.
%\end{proof}

Contrary to the well-known first recursion theorem, Kleene's second recursion theorem works for \emph{code} instead of values and will be used to model the \GL modality.

\begin{theorem}[SRT] \label{thm:SRT}
  For every $F : \Lambda_n$ there exists $M : \Lambda_n$ such that $M \reduce F\,\qquote{M}$.
\end{theorem}

\subsection{\texorpdfstring{$\PP$}{P}-Categories and exposures}
Instead of ordinary categories, we work with $\PP$-categories pioneered by \v{C}ubri\'c et al.~\cite{Cubric1998a}, where morphisms are equipped with an additional partial equivalence relation (PER) as another level of equality between morphisms.
Kavvos~\cite{Kavvos2017b} recently advocated its use and introduced a construct called \emph{exposure}, which is similar to a ($\PP$-)functor but does not enforce the preservation of PERs of $\PP$-categories, to manifest the essence of intensionality.

% We sketch the main idea of the works by \v{C}ubri\'c et al.\ and by Kavvos \emph{op.\ cit.} as follows.
\begin{definition}
  A \emph{partial equivalence relation} is a symmetric and transitive relation.
  A \emph{$\PP$-set} $(X, \sim_X)$ is a set $X$ with a PER~$\sim_X$.
  A \emph{$\PP$-function} from $(X, \sim_X)$ to $(Y, \sim_Y)$ is a function $f\colon X \to Y$ which respects the relation~$\sim$ in the sense that $f\,x \sim_Y f\,y$ whenever $x \sim_X y$.
  An element $x \in X$ is \emph{well-defined} (with respect to $\sim$) if $x \sim x$.
\end{definition}
The identity function $\idfunc[X]$ is a $\PP$-function, and the composite of $\PP$-functions is also a $\PP$-function.
Then we recall the notion of $\PP$-categories as follows.

\begin{definition}[{\cite[Definition~2.4]{Cubric1998a}}]
  A $\PP$-category is a category whose hom-sets are $\PP$-sets satisfying the associativity and identity laws up to~$\sim$ in the sense that 
  \begin{romanenumerate}
  \item every object~$X$ has an identity morphism $\iid_X$, 
  \item $g \circ f \sim g' \circ f'$ whenever $g\sim g'$ and $f \sim f'$,
  \item $\iid \circ f \sim f'$ and $f \circ \iid \sim f'$ whenever $f \sim f'$,%
  \item $h \circ (g \circ f) \sim (h' \circ g') \circ f'$ whenever $h\sim h'$, $g \sim g'$, and $f \sim f'$.
  \end{romanenumerate}
\end{definition}

A $\PP$-category has two kinds of equality for morphisms---the underlying equality $=$ and the PER~$\sim$, where the former can be used to model the \emph{intensional equality} and the latter the \emph{extensional equality} akin to the structure of multiple judgemental equalities in the modal type theory by Pfenning~\cite{Pfenning2002a}.
Having two different equalities $=$~and~$\sim$ reflects the fact that, for example, $\alpha$-equivalent terms are $\beta$-equivalent but not vice versa.
For categorical semantics, where terms are interpreted as morphisms, an interpretation into a $\PP$-category is able to discriminate these two kinds of equality, enabling us to model intensionality.
The usual categorical notions such as functors and initiality are up to the intensional equality~$=$\,; when we want to use the notions up to the extensional equality~$\sim$, we will add the `$\PP$-' prefix and say $\PP$-functors, $\PP$-initiality, etc.

We recall the notion of exposures, which are like $\PP$-functors but are intended to `expose' intensional differences at the extensional level: if an exposure is applied to intensionally different morphisms (which may or may not be identified extensionally), the resulting morphisms may be distinguished extensionally.
Consequently, exposures are not required to preserve the extensional equality.
Moreover, exposures are only supposed to refine the extensional equality and do not eliminate existing extensional differences, that is, exposures are faithful with respect to~$\sim$.
Put differently, intensionally equal morphisms, with respect to an exposure, should be extensionally equal.
The precise definition is given as follows.

\begin{definition}
  Given $\PP$-categories $\mathbf{C}$ and $\mathbf{D}$, an \emph{exposure} $Q\colon \mathbf{C} \looparrowright \mathbf{D}$ consists of \emph{(a)} a mapping $Q$ from objects $X$ of\/ $\mathbf{C}$ to objects~$QX$ of\/ $\mathbf{D}$ and \emph{(b)} from well-defined morphisms $f\colon X \to Y$ to well-defined morphisms $Qf\colon QX \to QY$ satisfying the following properties:
  \begin{romanenumerate}
    \item $Q\iid_X \sim \iid_{QX}$,
    \item $Q(g \circ f) \sim Qg \circ Qf$, and
    \item $f \sim g$ whenever $Qf \sim Qg$ for any two well-defined morphisms $f, g\colon X \to Y$. 
  \end{romanenumerate}
\end{definition}
The \emph{identity exposure} $\mathcal{I}$ maps every object or morphism to itself.
Composing two exposures in the usual way clearly gives us an exposure. 

Similarly, the notion of natural transformations is introduced for exposures, sharing the same idea with ordinary natural transformations but only up to~$\sim$.
\begin{definition}
  Given exposures $P, Q\colon \mathbf{C} \looparrowright \mathbf{D}$, a \emph{natural transformation of exposures} $t\colon P \to Q$ is a family of well-defined morphisms $t_X \colon PX \to QX$ such that $Qf \circ t_X \sim t_Y \circ Pf$ for every well-defined morphism~$f\colon X \to Y$. 
\end{definition}
An \emph{evaluator} for an endo-exposure~$Q$ is a natural transformation from $Q$ to $\mathcal{I}$, modelling the \textbf{T} axiom $\boxtimes A \to A$.
To model the \SFour modality, we may define \emph{comonadic exposures} introduced by Kavvos~\cite{Kavvos2017b} as an endo-exposure equipped with an evaluator and a natural transformation~$\delta\colon Q \to Q^2$, modelling the \textbf{4} axiom $\boxtimes A \to \boxtimes{\boxtimes A}$, subject to comonad laws.
In the presence of intensionality, however, we observe that the naturality is not always appropriate as discussed later in~\cref{re:naturality}.

\section{\texorpdfstring{$\PP$}{P}-Category of assemblies on \texorpdfstring{$\lambda$}{λ}-calculus}\label{sec:assemblies}

Assemblies are used to accommodate the information of how extensions are \emph{realised by} intensions.
Accordingly an appropriate notion of morphisms between assemblies is introduced to form a $\PP$-category, laying
the technical foundation for~\Cref{sec:S4-modality,sec:GL-modality}.


\subsection{Assembly and trackable map}
Traditionally, an assembly on natural numbers is a set $\bproj{X}$ with a realisability relation $\mathord{\Vdash} \subseteq \mathbb{N} \times |X|$ such that for every $x$ in $\bproj{X}$ there exists some $a$ with $a \Vdash x$, where $a$ is said to \emph{realise} $x$ or $a$ is a \emph{realiser} of $x$.
The modern notion of assemblies~\cite{Oosten2008} is often defined on a partial  combinatory algebra~$(A, \cdot)$, called \emph{PCA} for short, where $\cdot$ is a partial binary operation.
For the sake of formalisation and potential applications in programming language design, we base our definition on $\lambda$-calculus subject to $\alpha$-equivalence, which is more akin to the one based on an ordered PCA~\cite{Hofstra2003}. 

\begin{definition}\label{def:assembly}
  An \emph{assembly} $X$ on $\lambda$-calculus consists of a \emph{carrier} set $|X| : \set$ and a family ${\Vdash_X}$ of sets indexed by $\Lambda_0$ and $|X|$ as its \emph{realisability relation} such that
  \emph{(a)} there is merely a realiser $M : \Lambda_0$ of every $x : \bproj{X}$, and
  \emph{(b)} $M \Vdash_X x$ whenever $M \reduce N$ and $N \Vdash_X x$.
  In other words, an assembly is a quadruple $(|X|, \Vdash_X, r_X, t_X)$ of type
  \[
    \Asm_0 \defeq \sm{\bproj{X} : {\set}}{\mathord{\Vdash_X}:\Lambda_0 \to |X| \to \set} 
      \mathsf{Respects}\left(\Vdash_X, \mathord{\twoheadrightarrow_\beta}\right)
      \times \mathsf{RightTotal}({\Vdash_X})
  \]
  where
  \begin{align}
    \mathsf{Respects}\left(\mathord{\Vdash}, \mathord{\twoheadrightarrow_\beta}\right) & \defeq\prd{M N : \Lambda_0}{x : |X|} \left(M \twoheadrightarrow_ \beta N\right) \to \left(N \Vdash x\right) \to \left(M \Vdash x\right) \label{eq:respect-reduction} \\      
    \mathsf{RightTotal}(\Vdash) & \defeq \fall{x : |X|}\exis{M : \Lambda_0} M \Vdash x
    \label{eq:right-total}
  \end{align}
\end{definition}

Our type-theoretic formulation is almost a direct translation from the set-theoretic formulation except that the realisability relation~$\Vdash$ is not really a relation but an indexed family of sets.
As we would like to account for intensional equality in addition to extensional equality between terms,
computationally equivalent terms should not be identified \emph{a priori}.
It turns out that formulating the interaction with reduction $\reduce$ as~\eqref{eq:respect-reduction} in line with the definition on an ordered PCA suffices to derive familiar properties.
%The formulation $\left(\mathord{\Vdash_X}\;\mathsf{respects}\;\mathord{\twoheadrightarrow_\beta}\right)$ is motivated by the confluence of $\lambda$-calculus where every two $\beta$-equivalent terms $M_i$ have a confluent term $N$, i.e.\ $M_i \reduce N$ for $i = 1, 2$.
%Second, a plausible alternative to the right totality~\eqref{eq:right-total} one might expect is
%\begin{equation}\label{eq:alternative-right-totality}
%  \lprd{x : |X|} \lsm{M : \Lambda_0} M \Vdash x
%\end{equation}
%stating that each inhabitant $x : |X|$ has a choice of realisers.
%However, this is a stronger requirement than asking the mere existence of a realiser.
%With function extensionality valid in HoTT, we believe that the alternative type~\eqref{eq:alternative-right-totality} is in fact empty when $\bproj{X}$ considering Troelstra's argument~\cite{Troelstra1977}.

\begin{example}\label{ex:assembly-lambda}
  The type $\Lambda_0$ of closed terms with ${\reduce}$ as its realisability relation is an assembly $(\Lambda_0, \reduce, r_{\Lambda_0}, t_{\Lambda_0})$ where $r_{\Lambda_0}$ and $t_{\Lambda_0}$ are given by the transitivity and the reflexivity of~$\reduce$.
  That is, each term $M$ is realised by those reducible to~$M$.
\end{example}
Note that the assembly~$\Lambda_0$ does \emph{not} yet model code.
Indeed, in such case, $M$ should be realised by its \emph{code}~$\qquote{M}$ instead.
This is exactly the point of forthcoming sections.

\begin{example} \label{ex:assembly-naturals}
  Every natural number $n : \Nat$ is realised by terms reducible to its Church numeral~$\mathtt{c}_n$.
  That is, the type $\Nat$ of natural numbers with $M \Vdash_\Nat n$ whenever $M \reduce \mathtt{c}_n$ is an assembly where $r_\Nat$ and $t_\Nat$ are given by the transitivity and the reflexivity of~$\reduce$.
\end{example}

A morphism between assemblies on a PCA $(A, \cdot)$ is defined as a function~$f$ merely \emph{tracked by} some $b \in A$ in the sense that there merely exists some $b$ such that $b \cdot a \Vdash f\,x$ whenever $a \Vdash x$.
In this case, $b$ is called the \emph{tracker} of $f$.
It is noted by Kavvos~\cite{Kavvos2017b} that to bring out intensionality the tracker should be considered as part of the structure instead of a property.
\begin{definition}\label{def:trackable}
  Given assemblies $X$ and $Y$, a \emph{trackable map}~$f$ from $X$ to $Y$ consists of a function $\bproj{f} : |X| \to |Y|$ and a term $F : \Lambda_1$ such that $F[M] \Vdash \bproj{f}\,x$ whenever $M \Vdash x$.
  That is, the type~$\Asm_1(X, Y)$ of trackable maps is $\sm{\bproj{f} : |X| \to |Y|} \sm{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, \bproj{f})$ where
  \[
    \mathsf{Tracks}_{X, Y}(F, \bproj{f}) \defeq \prd{M : \Lambda_0}{x : |X|}
    \left(M \Vdash_X x\right) \to \left(F[M] \Vdash_Y \bproj{f}\, x\right).
  \]
  A \emph{merely trackable map} is an inhabitant of $\sm{\bproj{f} : |X| \to |Y|} \exis{F : \Lambda_1}\mathsf{Tracks}_{X, Y}(F, \bproj{f})$. 
\end{definition}

By definition, a trackable map~$f \equiv (f, F, \mathfrak{f})$ consists of not only a function~$\bproj{f}$ between carriers but also its tracker~$F$ and a transformation~$\mathfrak{f}$ of realisability.

\begin{example}
  Every assembly $X$ has an identity map $\iid_X \defeq (\idfunc[\bproj{X}], \mathtt{x}_0, \pr_3)$
  where
  \[
    \pr_3 \defeq \lam{M}{x}{r} r : \prd{M : \Lambda_0}{x : |X|} \left(M \Vdash_X x\right) \to \left(M  \Vdash_X x\right)
  \]
  since $\mathtt{x}_0[M]$ is judgementally equal to~$M$.
\end{example}

Now we proceed with defining the composition of trackable maps. Let $f\colon X \to Y$ and $g\colon Y \to Z$ be trackable maps.
Then, the term substitution $(G, F) \mapsto G [ F ]$ can be thought of as (intensional) function composition, since $G[F[M]] =_{\Lambda_0} G[F] [M]$ holds for any term $M$.
Given any $r : M \Vdash_X x$, the inhabitant $\mathfrak{g}(\mathfrak{f}\,r)$ has type $G[F[M]]$ and its transportation along a witness $p : G[F[M]] =_{\Lambda_0} G[F][M]$ has type $G[F][M]$, defining a function $\lambda M\,x\,r.\, \mathsf{transport}(p, \mathfrak{g}(\mathfrak{f}\,r))$.
The above discussion amounts to defining a composition operation $(g, f) \mapsto g \circ f$.

%Then, it is not hard (but tedious and laborious) to prove that assemblies and trackable maps form an ordinary category.

%\begin{proposition}\label{prop:category-of-assemblies}
%  The type $\ASM_0(\Lambda)$ of assemblies and the family of types $\ASM_1(X, Y)$ of trackable maps form a category.
%\end{proposition}

%We may also consider reductions $F_1 \reduce F_2$ between morphisms $(f_1, F_1, \mathfrak{f}_1)$
%and $(f_2, F_2, \mathfrak{f}_2)$ as two cells since $F_1 \reduce F_2$ implies $F_1[M] \reduce F_2[M]$.
%That is, we do have a $2$-category of assemblies in the spirit of Seely's $2$-categorical model~\cite{Seely1987}.
%This line of research is out of scope of this paper, so we refrain ourselves from further discussion. 

\subsection{Extensional equality and \texorpdfstring{$\PP$}{P}-category of assemblies}

We define the partial equivalence relation $\sim$, referred to as the extensional equality, on trackable maps by $f_1 \sim f_2$ ($f_1$ is \emph{extensionally equal} to $f_2$) if $\bproj{f_1} = \bproj{f_2}$.
\begin{proposition}
  The type $\Asm_0$ of assemblies and the family of types $\Asm_1(X, Y)$ for any two assemblies $X$ and $Y$ with the extensional equality form a $\PP$-category~$\Asm(\Lambda)$.
\end{proposition}

We now investigate some of its basic properties.
\begin{example}[$\PP$-Terminal object]
  The unit $\top \defeq (\Unit, \Vdash_\top, r_\top, t_\top)$ is $\PP$-terminal where 
  \begin{romanenumerate}
    \item $\Unit$ is the unit type,  
    \item $\Vdash_\top$ a relation defined by $M \Vdash_\top \star \defeq M \reduce \mathtt{I}$ where $\mathtt{I} \defeq \mathtt{\lambda x.\, x}$, 
    \item $r_\top : (M \reduce N) \to (N \reduce \mathtt{I}) \to (M \reduce \mathtt{I})$ given by the transitivity of $\reduce$,
    \item and $t_\top$ the fact that the only inhabitant $\star : \Unit$ has a realiser $\mathtt{I}$ (by reflexivity).
  \end{romanenumerate}
  The finality follows from function extensionality.
\end{example}
The construction of binary $\PP$-products is also typical---the carrier of a product is the cartesian product and a pair $(x, y)$ is realised by $M$ if its Church-encoded projections realise $x$ and $y$.
It follows that $\Asm(\Lambda)$ has finite $\PP$-products.

Every inhabitant of an assembly $X$ corresponds to a merely trackable map to $X$ from the terminal object $\top$, which are called \emph{(global) elements} of~$X$, and distinct merely trackable maps can be separated by elements of~$X$.
In $\Asm(\Lambda)$, as trackers are part of trackable maps, an element has to be constructed with an intension.
\begin{lemma}\label{lem:global-element}
  Let $X$ be an assembly. Then the following statements hold:
  \begin{enumerate}
    \item Every inhabitant $x : \bproj{X}$ corresponds to a merely trackable map from $\top$ to $X$.
    \item Every pair of $x : \bproj{X}$ and $M : \Lambda_0$ with $r : M \Vdash_X x$ defines a \emph{closed} element of $X$, i.e.\ a trackable map $(\lam{\anonymous}x, M, \lam{\anonymous}{\anonymous}{\anonymous}r)$ from $\top$ to $X$.
  \end{enumerate}
\end{lemma}

As expected, the $\PP$-terminal object $\top$ in~$\Asm(\Lambda)$ is a $\PP$-separator in the sense that for any two trackable maps $f_1$ and $f_2$ we have $f_1 \sim f_2$ if $f_1 \circ x \sim f_2 \circ x$ for every element~$x$ of~$X$.
Even further, we can restrict to closed elements.
%This restriction relies on the property that the carrier $\bproj{X}$ is a set.
\begin{proposition}
  Two trackable maps $f_1, f_2\colon X \to Y$ are extensionally equal if and only if $f_1 \circ x \sim f_2 \circ x$ for every closed element~$x\colon \top \to X$.
  In particular, the $\PP$-terminal object $\top$ is a $\PP$-separator in $\Asm(\Lambda)$.
\end{proposition}
\begin{proof}[Proof sketch]
  The proof from left to right is trivial.
  For the proof from right to left, let $f_1$ and $f_2$ be two trackable maps.
  By function extensionality, to prove that $\bproj{f_1} = \bproj{f_2}$, we define for any inhabitant $x : \bproj{X}$ a closed element $\hat{x}$ of $X$ constructed by \Cref{lem:global-element} using $M_x$ and $r : M_x \Vdash x$ given by the right totality $t_X$.
  By the recursion principle of propositional truncation and $\bproj{Y}$ being a set, it follows from our assumption that there exists a path $\bproj{f_1}\,x = \bproj{f_2}\, x$ independent of the choice of $M_x$ and $\mathfrak{M}_x$.
\end{proof}

%so we leave this as an exercise to the reader.
\begin{example}[Initial object]
The empty assembly $\bot$ is $\PP$-initial consisting of the empty type $\Empty$ and a relation $\Vdash_\bot : \Lambda_0 \to \Empty \to \set$ given by the elimination rule for the empty type.
The other two components $r_\bot$ and $t_\bot$ are trivial.
\end{example}

In addition, one can show that $\bot$ is even a \emph{strict} $\PP$-initial object. That is, 
\begin{proposition}\label{prop:strict-initial}
  Any trackable map from some assembly $X$ to $\bot$ is a $\PP$-isomorphism. 
\end{proposition}
%The strictness of $\bot$ follows easily from the fact that, for any type~$X$ with a function $X \to \Empty$, one can show the equivalence $\eqv{\Empty}{X}$ in HoTT.
From the strictness of the initial object, no morphism from $\top$ to $\bot$ could exist.

The construction of $\PP$-exponential $X \Rightarrow Y$ is a bit laborious and, perhaps surprisingly, $X \Rightarrow Y$ has the type of \emph{merely} trackable maps as its carrier.
%since the carrier is meant to be the type of \emph{extensions} of trackable maps.
%With the definition of trackable maps, we may expect the $\PP$-exponential $X \Rightarrow Y$ to consist of trackable maps.
\begin{example}[$\PP$-Exponential]
  Given assemblies $X$ and $Y$, define
  \begin{align*}
    \bproj{X \Rightarrow Y} & \defeq \sm{f : |X| \to |Y|} \exis{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, f) \equiv \sm{f : |X| \to |Y|} \brck{\sm{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, f) }
  \end{align*}
  with $L \Vdash_{X \Rightarrow Y} (f, \star) \defeq \prd{M : \Lambda_0}{x : |X|} \left( M \Vdash_X x\right) \to \left(L\,M \Vdash_Y f\,x\right)$.

  It remains to construct $r_{X\Rightarrow Y}$ and $t_{X \Rightarrow Y}$: 
  We know that $L' \reduce L$ implies $L'\,M \reduce L\,M$, so $L'$ realises $(f, \star)$ whenever $L$ realises $(f, \star)$ and $L' \reduce L$ by $r_Y$.
  For every $(f, \star) : |X \Rightarrow Y|$, there merely exists a tracker of $f$, say $F$.
  We see that $L \defeq \lam{\mathtt{x}}F$ realises $(f, \star)$, since
  $\left(\lam{\mathtt{x}}F\right)\,M \onereduce F[M]$ for any $M$ and $F[M] \Vdash_Y f\,x$ whenever $M \Vdash_X x$.
  By applying the recursion principle of the truncated type $\brck{\sm{F : \Lambda_1} \mathsf{Tracks}_{X, Y}(F, f) }$ to the second component of $(f, \star)$, there merely exists a realiser of $(f, \star)$ for the right totality.

  The \emph{evaluation map} $(X \Rightarrow Y) \times X \xrightarrow{\mathit{ev}_{X, Y}} Y$ natural in $X$ and $Y$ consists of a function
  $((f, \star) , x) \mapsto f\,x$ and its tracker $(\mathtt{proj}_1\, \mathtt{x}_0)\,(\mathtt{proj}_2\, \mathtt{x}_0) : \Lambda_1$ where $\mathtt{x}_0$ is the free variable (thought of as a pair of realisers for a function and its argument) and $\mathtt{proj}_i$ the projection function between $\lambda$-terms.

  The \emph{curried map} $(f^*, F^*, \mathfrak{f}^*)$ of a trackable function $(f, F, \mathfrak{f})$ from $Z \times X$ to $Y$ consists of
    a function
    $f^* \defeq \lam{z}((\lam{x}f\,(z, x)) , \star_z)$, 
    where by the recursion principle on the mere existence of a realiser $L_z \defeq t_Z z$ there is merely a tracker~$F[\left< L_z , \mathtt{x}_0 \right>]$ of $\lam{x}f\,(z, x)$, and
    a term $F^* \defeq \lam{\mathtt{x}_0}F[ \left< \mathtt{x}_1, \mathtt{x}_0 \right> ]$ with 
    a witness $\mathfrak{f}^*$ of $\prd{L : \Lambda_0}{z : |Z|} \left(L \Vdash_Z z\right) \to \left(F^*[L] \Vdash_{X \Rightarrow Y} f\, z\right)$ because of the reduction
      \[
        \left(\lam{\mathtt{x}_0} F[\left< L , \mathtt{x}_0 \right>]\right)\,M \onereduce F[\left< L , M \right>]
      \]
      and that $F$ is indeed a tracker of~$f\colon \bproj{Z \times X} \to \bproj{Y}$. 
  It is routine to verify remaining details.
\end{example}

\begin{corollary}
  $\Asm(\Lambda)$ is a cartesian closed $\PP$-category with a strict $\PP$-initial object.
\end{corollary}

\section{Realisability semantics for the \texorpdfstring{\SFour}{S4} modality}\label{sec:S4-modality}

We are now ready to introduce an exposure $\boxtimes\colon \Asm(\Lambda) \looparrowright \Asm(\Lambda)$ modelling the \SFour modality (validating the \textbf{K} axiom ${\boxtimes}(A \to B) \to \boxtimes A \to \boxtimes B$, the \textbf{4} axiom $A \to {\boxtimes} {\boxtimes} A$, and the \textbf{T} axiom ${\boxtimes} A \to A$) and show that a generic quoting $X \to \boxtimes X$ cannot exist.

\subsection{An exposure for the \texorpdfstring{\SFour}{S4} modality}
Given an assembly~$X$, which describes a set of extensions merely realised by some intensions (i.e.\ terms), we can expose the intensions at the level of extensions by constructing an assembly $\boxtimes X$ where an inhabitant $(M, x, r) : \bproj{\boxtimes X}$ is an extension $x : \bproj{X}$ and a term $M : \Lambda_0$ that realises~$x$, witnessed by $r : M \Vdash_X x$.
This term~$M$ becomes the main part of the extension (with respect to $\boxtimes X$) and should be (merely) realised by some intensional representation of~$M$; a natural choice of such representation is $\qquote{M}$, or indeed any term $\beta$-reducible to $\qquote{M}$.
In short, the carrier and the realisability relation of $\boxtimes X$ are defined as
\[
  \bproj{\boxtimes X} \defeq \sm{M : \Lambda_0}{x : \bproj{X}} M \Vdash_X x
  \quad\text{and}\quad
  \left(N \Vdash_{\boxtimes X} (M, x, r)\right) \defeq N \reduce \qquote{M}
\]
respectively.
It turns out that $\boxtimes X \defeq (\bproj{\boxtimes X}, \Vdash_{\boxtimes X}, r_{\boxtimes X}, t_{\boxtimes X})$ is indeed an assembly where $r_{\boxtimes X}$ and $t_{\boxtimes X}$ are the transitivity and the reflexivity of $\reduce$.

To make $\boxtimes$ an exposure, we should also define the mapping on morphisms.
Consider any trackable map~$f$ from~$X$ to~$Y$ and define $\boxtimes f \defeq (\bproj{f}^\boxtimes, F^\boxtimes, \mathfrak{f}^\boxtimes)\colon {\boxtimes} X \to \boxtimes Y$ as follows.
First define a function from $\bproj{\boxtimes X}$ to $\bproj{\boxtimes Y}$ by
\[
  \bproj{f}^\boxtimes\colon (M, x, r) \mapsto (F[M], \bproj{f}\,x, \mathfrak{f}\,M\,x\,r).
\]
To give a tracker of $\boxtimes f$, recall that there is a term $\mathtt{subst}$ performing term substitution on codes (\Cref{sec:lambda}), and then the term $F^\boxtimes \defeq \mathtt{subst}\,\qquote{F}\,\mathtt{x}$ tracks $\bproj{f}^\boxtimes$ because
\begin{align*}
  \mathtt{subst}\,\qquote{F}\,N 
  \reduce \mathtt{subst}\,\qquote{F}\,\qquote{M}
  \reduce \qquote{F[M]} ~\Vdash_{\boxtimes Y} \bproj{f}^\boxtimes(M, x, r)
\end{align*}
completing the definition of $\mathfrak{f}^\boxtimes$.
In short, $\boxtimes f\defeq(\bproj{f}^\boxtimes, F^\boxtimes, \mathfrak{f}^\boxtimes)$ is a trackable map.

\begin{definition} \label{ex:global-element-of-unit}
  By $\bigstar\colon \top \to \boxtimes \top$ we denote a closed element of~$\boxtimes \top$ given by \Cref{lem:global-element} with $(\mathtt{I}, \star, \refl_\twoheadrightarrow) : \bproj{\boxtimes \top}$ and its realiser $\qquote{\mathtt{I}}$.%
\end{definition}
\begin{remark}
  Given elements $a, b$ of $X$ with $a \sim b$ but with different trackers, it follows that by definition $\boxtimes a \circ \bigstar \not\sim \boxtimes b \circ \bigstar$ are two extensionally different elements.
  That is, $\boxtimes$~does not preserve extensional equality.
\end{remark}

The assembly $\boxtimes \top$ cannot be $\PP$-isomorphic to $\top$, since there are countably many inhabitants of $\bproj{\boxtimes \top}$ while there is exactly one inhabitant of $\bproj{\top} \equiv \Unit$. 
Similarly, there are trackable maps from $\boxtimes (X \times Y)$ to $\boxtimes X \times \boxtimes Y$ and vice versa, but they are not $\PP$-isomorphic.
It follows that the exposure $\boxtimes$ does not preserve finite $\PP$-products.

\begin{theorem}\label{thm:S4-exposure}
  $\boxtimes\colon \Asm(\Lambda) \looparrowright \Asm(\Lambda)$ is an exposure of assemblies.
  Moreover, there is an evaluator $\epsilon$ for $\boxtimes$, i.e.\ a natural transformation~$\epsilon$ from $\boxtimes$ to $\mathcal{I}$.
\end{theorem}

\begin{proof}[Proof sketch]
  It is routine to prove the preservation of identities and composition.
  For example, it follows by definition that $\idfunc[\bproj{X}]^\boxtimes (M, x, r) \equiv (\mathtt{x}[M], x, \pr_3\,M\,x\,r) \equiv (M, x, r)$.

  Now we show that $\boxtimes$ reflects the extensional equality.
  Let $f$~and~$g$ be trackable maps from~$X$ to~$Y$.
  By assumptions that $\boxtimes f \sim \boxtimes g$ and that there is merely $M : \Lambda_0$ with $r : M \Vdash_X x$, we can apply
  the recursion principle of propositional truncation to derive 
  \[
    \boxtimes f(M, x, r) = (F[M], \bproj{f}\,x, \mathfrak{f}\,M\,x\,r)
    = (G[M], \bproj{g}\,x, \mathfrak{g}\,M\,x\,r) = \boxtimes g (M, x, r)
  \]
  since the equality type on $\boxtimes Y$ is a proposition.
  Therefore, we have $\prd{x : \bproj{X}} \bproj{f}\,x =_Y \bproj{g}\,x$.
  By function extensionality it then follows that $\left(\bproj{f} =_{\bproj{X} \to \bproj{Y}} \bproj{g}\right) \equiv f \sim g$.

  As for the evaluator $\epsilon_X\colon {\boxtimes} X \to X$, recall the term $\mathtt{eval}$ which evaluates a code (\Cref{sec:lambda}). 
  We simply define $\bproj{\epsilon_X}$ by $(M, x, r) \mapsto x$. 
  Then, given $N : \Lambda_0$ with $N \reduce \qquote{M}$, we have $\mathtt{eval}[N] \reduce \mathtt{eval}[\,\qquote{M}\,] \reduce M$ where $M \Vdash_X x$ is witnessed by~$r$.
  That is, $\bproj{\epsilon_X}$ is tracked by~$\mathtt{eval}$.
  The naturality of $\epsilon$ follows by definition.
\end{proof}

Given an element~$a$ of~$X$, define its \emph{quotation} as the element $\boxtimes a \circ \bigstar$ of~$\boxtimes X$.
The choice of $\bigstar$ does not matter if $a$ is closed, since $\boxtimes a \circ \bigstar' \sim \boxtimes a \circ \bigstar$ for any element~$\bigstar'$ of $\boxtimes \top$.  
We say that a trackable map $q\colon X \to \boxtimes X$ \emph{quotes} an element $a$ of~$X$ whenever $q \circ a \sim {\boxtimes}a \circ \bigstar$.
%thought as a reduction $\mathtt{q}[a/x] \mapsto \qquote{a}$
%\[
%  \xymatrix{
%    \top \ar[d]_{a} \ar[r]^{\bigstar} & \boxtimes \top \ar[d]^{\boxtimes a} \\
%    X \ar[r]_{q} & {\boxtimes} X.
%  }
%\]
The (\textbf{4}) axiom can be realised by a family of trackable maps which quote closed elements:
\begin{proposition} \label{prop:four-rule}
There is a family of functions $\bproj{\delta_X}(M, x, r) \defeq (\qquote{M}, (M, x, r), \refl_\twoheadrightarrow)$ indexed by objects~$X$ from $\bproj{\boxtimes X}$ to $\bproj{{\boxtimes} {\boxtimes} X}$ and tracked by~$\mathtt{quote}$, which quote closed elements of~$\boxtimes X$.%
%  \[
%    \bproj{\delta_X}(a(\star)) \equiv \bproj{\delta_X}(M, x, r) \equiv (\qquote{M}, (M, x, r), \refl_\twoheadrightarrow)
%    = \bproj{\boxtimes a}(\mathtt{I}, \star, \refl_\twoheadrightarrow) \equiv \bproj{\boxtimes a}(\bigstar(\star)).
%  \]
\end{proposition}
The fact that $\delta_X$ quotes closed elements justifies the computational meaning categorically.
Yet, $\delta_X$ may fail to quote an element~$a$ if $a$~is not closed, since in general the intension part of $\boxtimes a$ is applied only verbatim.
That is, $\bproj{\boxtimes a}(\mathtt{I}, \star, \refl_\twoheadrightarrow)$ is $ (F[\mathtt{I}], (M, x, r), s)$ where $F[\mathtt{I}]$ is not necessarily $\alpha$-equivalent to~$\qquote{M}$.
The subtlety goes on:
\begin{remark} \label{re:naturality}
One may expect that $(\boxtimes, \epsilon, \delta)$ is comonadic in the sense that $\delta$ is a natural transformation up to~$\sim$ satisfying comonad laws, but these maps $\delta_X$ are \emph{not} natural in~$X$.
In detail, for each trackable map $f\colon X \to Y$ the inhabitant 
\[
  \delta_Y (\boxtimes f(M, x, r))
  \equiv \left(\qquote{F[M]}, (F[M], f\,x, \mathfrak{f}\,M\,x\,r), \refl_{\twoheadrightarrow}\right) : {\boxtimes} {\boxtimes} Y
\]
 is not equal to
\[
  {\boxtimes} {\boxtimes} f (\delta_X(M, x, r))
  \equiv (\mathsf{subst}\,\qquote{F}\,\qquote{M}, (F[M], f\,x, \mathfrak{f}\,M\,x\,r), \mathsf{subst}_{\twoheadrightarrow}) : {\boxtimes} {\boxtimes} Y
\]
despite that their extensions are the same, where $\mathsf{subst}_{\twoheadrightarrow}$ is the witness of the reduction sequence $\mathsf{subst}\,\qquote{F}\,\qquote{M} \reduce \qquote{F[M]}$.
Let us define $(M, x, r) \leq (N, y, s)$ if $M \reduce N$ and $x = y$ and $f \leq g$ if $\bproj{f}\,x \leq \bproj{g}\,x$ for all~$x$.
Then we only have $\bproj{{\boxtimes} {\boxtimes} f \circ \delta_X} \leq \bproj{\delta_Y \circ {\boxtimes} f}$.
In general, the \emph{lax naturality} appears more appropriate in the presence of intensionality.
\end{remark}

The normality condition is realised exactly by~$\mathtt{ap}$ without naturality:
\begin{proposition}
There is a family of trackable maps
from $\boxtimes (X \Rightarrow Y)$ to $\boxtimes X \Rightarrow \boxtimes Y$  tracked by $\lam{\mathtt{x_0}}\mathtt{ap}[\mathtt{x_1}]\;\mathtt{x_0}$.
\end{proposition}

On the other hand, it is impossible for the rule $A \to \boxtimes A$ to compute quotations for arbitrary~$A$, since this is already impossible for the particular case of $\Lambda_0 \to {\boxtimes} \Lambda_0$ (where $\Lambda_0$ was given in \Cref{ex:assembly-lambda}).
%The key is the following lemma which relies on~\Cref{prop:no-quoting}.

%\begin{lemma}\label{lem:no-quoting}
%  The function $\bproj{\Lambda_0} \to \bproj{\boxtimes \Lambda_0}$ given by $M \mapsto (M, M, \refl_\twoheadrightarrow)$ cannot be tracked.
%\end{lemma}
%\begin{proof}
%  Suppose that $\eta_\Lambda$ is tracked by~$\mathtt{Q}$.
%  Being a tracker for a function from $\Lambda_0$ to $\boxtimes \Lambda_0$ means that $\mathtt{Q}[N]\reduce \qquote{M}$ whenever $N \reduce M$.
%  In particular, it follows that $\mathtt{Q}[M] \reduce \qquote{M}$.
%  By~\Cref{prop:no-quoting} such $\mathtt{Q}$ cannot exist.
%\end{proof}

\begin{theorem}\label{thm:S4-no-quoting}
  No trackable map from $\Lambda_0$ to $\boxtimes \Lambda_0$ quotes closed elements of~$\Lambda_0$.
  %$\eta_\Lambda \circ a \sim \boxtimes a \circ \eta_\top$ for closed elements~$a$ of $\Lambda$.
%  In particular, there is no natural transformation $\eta$ from $\mathcal{I}$ to $\boxtimes$.
\end{theorem}
\begin{proof}
  Assume $\eta \colon \Lambda_0 \to {\boxtimes} \Lambda_0$ with $\eta \circ a \sim {\boxtimes} a \circ \bigstar$ for any $a \colon \top \to \Lambda_0$ given by \Cref{lem:global-element}.
  Every closed term $M$ defines an element $\widehat{M} \defeq (\lam{\anonymous}M, M, \lam{\anonymous}{\anonymous}{\anonymous}\refl_\twoheadrightarrow)$ of $\Lambda_0$ and thus $\bproj{\boxtimes\widehat{M}}(N, y, s) = (M, M, \refl_\twoheadrightarrow)$ for any $(N, y, s) : \boxtimes \top$ by definition.
  By assumption
  \[
    \bproj{\eta}\,M \equiv \bproj{\eta} \left(\bproj{\widehat{M}}\,\star\right) =  \bproj{\boxtimes\widehat{M}}\,(\bproj{\bigstar}\,\star) = (M, M, \refl_\twoheadrightarrow),
  \]
  so the tracker~$\mathtt{Q}$ of~$\eta$ should satisfy $\mathtt{Q}[N]\reduce \qquote{M}$ whenever $N \reduce M$.
  In particular, it follows that $\mathtt{Q}[M] \reduce \qquote{M}$.
  By~\Cref{prop:no-quoting} such $\mathtt{Q}$ cannot exist. 
\end{proof}

%\begin{remark}\label{re:S4-modality}
%  Recall that the modal type theory considered by Davies and Pfenning~\cite{Davies2001b} is a dual-context simple type theory extended with an \SFour modality $\Box$, a construct $\mathtt{box}$, a $\mathtt{let}$-expression for boxed terms, and typing rules below.
%\[
%\begin{minipage}{.47\linewidth}
%  \begin{prooftree}
%    \AxiomC{$\Delta; \cdot \vdash E : A$}
%    \UnaryInfC{$\Delta; \Gamma \vdash \mathtt{box}\,E:\Box A$}
%  \end{prooftree}
%\end{minipage}%
%\begin{minipage}{0.47\linewidth}
%  \begin{prooftree}
%    \AxiomC{$\Delta; \Gamma \vdash E_1 : \Box A$}
%    \AxiomC{$\Delta, u : A; \Gamma \vdash E_2 : B$}
%  \BinaryInfC{$\Delta; \Gamma \vdash \mathtt{let}\,\mathtt{box}\, u = E_1\, \mathtt{in}\,E_2 : B$}
%  \end{prooftree}
%\end{minipage}
%\]
%
%Following \Cref{thm:S4-exposure,thm:S4-no-quoting}, we anticipate an interpretation of $\Box$ to justify the `omitted congruence rule' for the $\mathtt{box}$ construct~\cite[Section~2.5]{Davies2001b} and the absence of quoting function $A \to \Box A$ in their system.
%\hsnote{a brief recap on the `omitted congruence rule'}
%\end{remark}
As the choice of $\bigstar$ does not matter for closed elements~$a$, the above theorem shows that even a very limited form of naturality for any two morphisms $\eta_{\Lambda_0}$ and $\eta_\top$ satisfying $\eta_{\Lambda_0} \circ a \sim \boxtimes{a} \circ \eta_{\top}$ for any closed element~$a$ remains impossible. 
It is unclear how to state `parametricity' for~$\boxtimes$ so that any family of morphisms from $A$ to $\boxtimes A$, satisfying a reasonable naturality, can be rejected. 

\section{Realisability semantics for the \texorpdfstring{\GL}{GL} modality}\label{sec:GL-modality}

Kavvos~\cite{Kavvos2017b} advocated that the provability modality~$\Box$ and the \GL axiom $\Box(\Box A \to A) \to \Box A$ can also be understood as the type of code of type~$A$ and as intensional recursion respectively from the computational perspective.
Since we already have an exposure~$\boxtimes$ modelling typed code, a natural approach is to extend~$\boxtimes$ to model the \GL axiom in addition to \SFour.
However, it is known that the \GL axiom is incompatible with the reflection principle $\Box A \to A$.
Indeed, let $A$~be the falsity $\bot$ for both laws.
Then, we have $\Box(\Box \bot \to \bot) \to \Box \bot$ and $\Box \bot \to \bot$.
By the necessitation rule we can derive $\Box (\Box \bot \to \bot)$ and thus by modus ponens we can derive $\Box \bot$ and finally~$\bot$.
Therefore, by \Cref{prop:strict-initial,thm:S4-exposure}, we cannot expect the exposure $\boxtimes$ to model the \GL axiom if we want the type system to be logically consistent.

To untie the knot and retain consistency and the understanding of $\Box A$ as code of type~$A$, we observe that in general $\Box A$ and $\boxtimes A$ are types for different kinds of code and should be kept separate: code constructed with intensional recursion can only be expanded in stages (or otherwise may result in non-termination), whereas code supporting \SFour is only a special case where next stages include the current one, so that $\epsilon_X\colon {\boxtimes} X \to X$ is allowed.
Therefore, separately from~$\boxtimes$, we give an exposure $\Box \colon \Asm(\Lambda) \looparrowright \Asm(\Lambda)$ modelling the \GL modality in a staged setting (\Cref{sec:GL}).
The construction refutes both $X \to \Box X$ (by the same argument for~$\boxtimes$) and the reflection principle $\Box X \to X$.
We also derive the \GL axiom as well as its deductive form.
To express staged constructions more conveniently (without stage indexing), we work within guarded type theory.

\subsection{Digression: Clocked cubical type theory}
We use a particular version of guarded type theory---\emph{clocked cubical type theory}~\cite{Kristensen2021}, CCTT for short.
It extends HoTT with a later modality $\laterp^\kappa$, parametrised by a `clock'~$\kappa$, and guarded recursion. 
Here we only intuitively introduce the constructs and properties of CCTT that are necessary for the informal presentation of the constructions in \Cref{sec:GL}, but the formal details are all checked in \textsc{Agda} in the guarded cubical mode.
%The particular version of guarded type theory we use is \emph{clocked cubical type theory} (CCTT for short)~\cite{Kristensen2021}, which is a metalanguage extending HoTT with a later modality $\laterp^\kappa$ parametrised by a `clock'~$\kappa$ and guarded recursion and implemented in Agda~\cite{Veltri2020}.
%Here we only intuitively introduce the constructs and properties of CCTT that are necessary for the informal presentation of the constructions in \Cref{sec:GL}, but the formal details are all checked in Agda.

%It combines two extensions of dependent type theory.
%The first extension is the machinery to manipulate $n$-dimensional cubes such as paths, squares, cubes, etc., allowing us to prove Voevodsky’s univalence axiom and function extensionality.
%The second extension adds a sort $\clock$ with \emph{ticks}~\cite{Bahr2017} to support Nakano's later modality~$\laterp$ and guarded recursion, where the latter is also known as \emph{Löb induction}.
%\ltnote{can we be more informal about CCTT so that we can remove this section?}
%\hsnote{Maybe we could just do it `synthetically' or `on demand', stating/highlighting only the constructs and properties we need.}

%Clocks are of a different sort $\clock$ from types, so the usual type formers (such as `$\to$') are not applicable.
%A clock~$\kappa$ is introduced by a clock quantification~$\forall \kappa.\, A$ into a context with rules similar to those for $\Pi$-types:
%\[
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma, \kappa : \clock \vdash t : A$}
%      \UnaryInfC{$\Gamma \vdash \Lambda \kappa.\, t : \forall \kappa.\, A $}
%    \end{prooftree}
%  \end{minipage}
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma \vdash t : \forall \kappa.\, A$}
%      \AxiomC{$\Gamma \vdash \kappa' : \clock $}
%      \BinaryInfC{$\Gamma \vdash t[\kappa'/\kappa] : A[\kappa'/\kappa]$}
%    \end{prooftree}
%  \end{minipage}
%\]
%For convenience, a clock constant~$\kappa_0$ is presumed in the type theory.%
%\hsnote{Just for convenience?}

CCTT features a new type $\laterp (\alpha : \kappa).\, A$ of suspended computations that take in a tick~$\alpha$ on a clock~$\kappa$ to produce an inhabitant of~$A$ in a next stage.
(Clocks will be discussed towards the end and can be ignored for now.)
An inhabitant of $\laterp (\alpha : \kappa).\, A$ therefore resembles a function computationally, and can be introduced as a $\lambda$-expression $\lam{\alpha : \kappa}t$, often abbreviated to $\lam{\alpha}t$, where $t : A$, or eliminated by application to a tick, denoted by $f[\alpha] : A$ where $f : \laterp (\alpha : \kappa).\, A$ and $\alpha : \kappa$.
For brevity, $\laterp (\alpha : \kappa).\,A$ is written as $\laterp^\kappa\, A$ if $\alpha$~is not referred to in~$A$.
For example, the following term implements the normality axiom for $\laterp^\kappa$:
\[
  \mathsf{ap}^\kappa \defeq \lam{f}{x}{\alpha}f[\alpha]\,(x[\alpha]) : \laterp^\kappa(A \to B) \to \laterp^\kappa A \to \laterp^\kappa B.
\]
Viewed as a function, $\mathsf{ap}^\kappa$ takes $f : \laterp^\kappa(A \to B)$ and $x : \laterp^\kappa A$ as arguments, both of which are values that can be used in a next stage, and should produce a result of type~$\laterp^\kappa B$, that is, a value of type~$B$ in a next stage; this result is constructed by first taking in a tick~$\alpha$---after which the rest of the term describes a construction in the next stage---and then applying both $f$~and~$x$ to~$\alpha$ to produce $f[\alpha] : A \to B$, $x[\alpha] : A$, and eventually $f[\alpha]\,(x[\alpha]) : B$ in the next stage.
Another important example is delaying a value to a next stage:
\[
  \mathsf{next}^\kappa \defeq \lam{x}{\alpha}x : A \to \laterp^\kappa A.
\]
In contrast to $\mathsf{next}^\kappa$, there is no term of type $\laterp^\kappa A \to A$, matching our intuition about a series of stages happening in order: in the current stage we should not be able to obtain a value that is only available in the next stage.
Also there is no term of type $\laterp^\kappa \laterp^\kappa A \to \laterp^\kappa A$---it might be tempting to write $\lam{x}{\alpha}x[\alpha][\alpha]$, but the two consecutive applications to~$\alpha$ are prohibited in CCTT.

An important primitive is \emph{guarded recursion}, also known as \emph{Löb induction}: every function $f : \laterp^\kappa A \to A$ has a delayed fixed point $\mathsf{dfix}^\kappa\,f : \laterp^\kappa A$ with the fixed point equation $(\mathsf{dfix}^\kappa\,f)[\alpha] =_A f\,(\mathsf{dfix}^\kappa\,f)$ where the right-hand side can be seen as a fixed point of~$f$ without delay.

%\[
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma \vdash t : \laterp^\kappa A \to A$}
%      \UnaryInfC{$\Gamma \vdash \mathsf{dfix}^\kappa\,t : \laterp^\kappa A$}
%    \end{prooftree}
%  \end{minipage}
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma \vdash t : \laterp^\kappa A \to A$}
%      \UnaryInfC{$\Gamma \vdash \mathsf{pfix}^\kappa\,t : (\mathsf{dfix}^\kappa\,t)[\alpha] =_A t(\mathsf{dfix}^\kappa\,t)$}
%    \end{prooftree}
%  \end{minipage}
%\]

%Formally, the rules for ticks are as follows:
%\[
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma, \alpha : \kappa \vdash t : A$}
%      \UnaryInfC{$\Gamma \vdash \lambda (\alpha : \kappa).\, t : \laterp (\alpha : \kappa).\, A$}
%    \end{prooftree}
%  \end{minipage}
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma \vdash t : \laterp (\alpha : \kappa).\, A$}
%      \AxiomC{$\Gamma, \beta : \kappa, \Gamma' \vdash$}
%      \BinaryInfC{$\Gamma, \beta : \kappa , \Gamma' \vdash t[\beta] : A[\beta/\alpha]$}
%    \end{prooftree}
%  \end{minipage}
%\]
%where the elimination rule separates variables occurring before and after $\alpha$ in a context.
%The elimination rule reflects the intuition that a tick is a kind of resource.
%For example, $\lambda (x : \laterp^\kappa\,\laterp^\kappa\,A).\, \lambda (\alpha : \kappa).\, x [\alpha][\alpha]$
%is not typable (because $\alpha$~is wrongly used twice) but the following term is:
%\[
%  \Lambda \kappa.\, \lambda f.\,\lambda x.\,\lambda \alpha.\, f[\alpha]\,(x[\alpha]) : \forall \kappa.\, \laterp^\kappa(A \to B) \to \laterp^\kappa A \to \laterp^\kappa B.
%\]
%An inhabitant of $A$ is available in a time step given by $\mathtt{next} \defeq \Lambda \kappa.\, \lambda x.\,\lambda \alpha.\, x \colon \forall \kappa.\, A \to \laterp^\kappa A$.%
%\hsnote{later type, abstraction, and application, using $\mathtt{ap}$ and $\mathtt{next}$ as examples; then stage distinction (which is good) but no injectivity of $\mathtt{next}$ (which is not good), hence the introduction of clocks; goes on to guarded recursion, and the properties needed}

%An inhabitant of $\laterp (\alpha : \kappa).\, A$ can tick on a different clock by a constant tick~$\diamond$ stated by 
%\begin{prooftree}
%  \AxiomC{$\Gamma, \kappa : \clock \vdash t : \laterp (\alpha : \kappa).\, A$}
%  \AxiomC{$\Gamma \vdash \kappa' : \clock$}
%  \BinaryInfC{$\Gamma \vdash (t[\kappa'/\kappa])[\diamond] : A[\kappa'/\kappa][\diamond/\alpha]$}
%\end{prooftree}
%allowing $\laterp^\kappa$ to be eliminated in a clock~$\kappa'$ different from~$\kappa$.
%This tick~$\diamond$ is needed to type Atkey and McBride's~\cite{Atkey2013b} operator
%  $\mathsf{force} \defeq \lambda x.\, \Lambda \kappa.\, x[\kappa][\diamond]
%  : (\forall \kappa.\, \laterp^\kappa A) \to \forall \kappa.\, A$.

%  Finally, every function $t : \laterp^\kappa A \to A$ has a delayed fixed point $\mathsf{dfix}^\kappa\,t : \laterp^\kappa A$ with a path replacing the judgemental fixed point equation (to ensure the termination of reduction semantics); this is guarded recursion, also known as Löb induction:
%\[
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma \vdash t : \laterp^\kappa A \to A$}
%      \UnaryInfC{$\Gamma \vdash \mathsf{dfix}^\kappa\,t : \laterp^\kappa A$}
%    \end{prooftree}
%  \end{minipage}
%  \begin{minipage}{0.47\linewidth}
%    \begin{prooftree}
%      \AxiomC{$\Gamma \vdash t : \laterp^\kappa A \to A$}
%      \UnaryInfC{$\Gamma \vdash \mathsf{pfix}^\kappa\,t : (\mathsf{dfix}^\kappa\,t)[\alpha] =_A t(\mathsf{dfix}^\kappa\,t)$}
%    \end{prooftree}
%  \end{minipage}
%\]
%We can further derive the fixed point $t(\mathsf{dfix}^\kappa\,t) : A$ without any delay.

We now list some properties needed for~\Cref{sec:GL}.
The first one helps to assure that we are still working with propositions and sets even when $\laterp^\kappa$ is involved.
\begin{lemma}
  If $A[\alpha]$ is a proposition/set for arbitrary $\alpha : \kappa$, then so is $\laterp(\alpha: \kappa).\, A [\alpha]$.
\end{lemma}
%Being a proposition is irrelevant to ticks, and so is being a set.
%The proof is based on the fact that tick variables cannot be exchanged in a context with ordinary variables but variables of the interval~$\mathbb{I}$.
%\begin{lemma}
%  If $\laterp (\alpha : \kappa).\, \mathsf{isProp}\,(A [\alpha])$ is inhabited, then so is $\mathsf{isProp}\,(\laterp(\alpha: \kappa).\, A [\alpha])$. 
%  Similarly, if $\laterp (\alpha : \kappa).\, \mathsf{isSet}\,(A [\alpha])$ is inhabited, then so is $\mathsf{isSet}\,(\laterp(\alpha: \kappa).\, A [\alpha])$. 
%\end{lemma}
The later modality distributes over a $\Sigma$-type.
%It follows from the fact that the function from $\sm{x : \laterp^\kappa A} \laterp (\alpha : \kappa).\, B\,(x[\alpha])$ to $\laterp^\kappa \left(\sm{x : A} B\,x\right)$ mapping $(x, y)$ to $\lambda (\alpha : \kappa).\, (x[\alpha], y[\alpha])$ has a quasi-inverse, which entails an equivalence between the types.
\begin{lemma}\label{lem:later-sum}
  Let $B(x)$ be a family of types indexed by $x : A$.
  Then there are functions from $\laterp^\kappa \sm{x : A} B(x)$ to $\sm{x : \laterp^\kappa A} \laterp (\alpha : \kappa).\, B(x [\alpha])$ and vice versa.
  In fact, the two types are equivalent.
\end{lemma}
Therefore guarded recursion has a specialised form for $\Sigma$-types.
\begin{corollary} \label{coro:lob-induction-sum}
  Let $B(x)$ be a family of types indexed by $x : A$.
  Then
  \[
    \sm{x : \laterp A} \laterp (\alpha : \kappa).\,B(x[\alpha]) \to \sm{x : A} B(x) \quad\text{implies}\quad \sm{x : A} B(x).
  \]
\end{corollary}
%The $\mathtt{force}$ operator is an inverse of~$\mathtt{next}$ in the following sense:%
%\hsnote{Purely for proving the proposition below? (No other use of $\mathtt{force}$?)}
%\begin{lemma}
%  Let $x$ be an inhabitant of $\forall \kappa.\, A$. Then, 
%  $\mathtt{force}\,(\lambda \kappa.\,\lambda (\alpha : \kappa).\, x [\kappa])\,\kappa = x\,\kappa$ is inhabited for any clock $\kappa$.
%\end{lemma}
The final property states that if two values delayed to a next stage are equal, then they are equal in the current stage.
It may be tempting to formulate the property as $\mathsf{next}^\kappa\, x =_{\laterp^\kappa A} \mathsf{next}^\kappa\, y \to x =_A y$, but this is in fact invalid, since (analogously to function extensionality) the antecedent equality is equivalent to $\laterp^\kappa (x =_A y)$ rather than $x =_A y$~\cite{Mogelberg2019a}.
The correct formulation is the following, where the antecedent includes a \emph{clock quantification}~`$\forall\kappa$'.
\begin{lemma}\label{lem:later-identity}
  Let $x$ and $y : A$. Then $x =_A y$ if\/ $\forall \kappa.\, \mathsf{next}^\kappa\,x =_{\laterp^\kappa A} \mathsf{next}^\kappa\,y$.
\end{lemma}
This lemma holds because, with clock quantification, it is possible to write Atkey and McBride's~\cite{Atkey2013b} operator $\mathsf{force} : (\forall\kappa.\, \laterp^\kappa A) \to (\forall\kappa.\, A)$, which can then be applied to the equality $\forall\kappa.\, \laterp^\kappa (x =_A y)$ equivalent to the antecedent and yield $\forall\kappa.\, x =_A y$, which is equivalent to $x =_A y$.
One way to think about (fully) clock-quantified types is that they are independent of the choice of clocks and can be viewed as the types of pure, completed descriptions of staged computation rather than ongoing computations that are taking effect in stages with respect to a particular clock in scope.
We can manipulate such descriptions at will, irrespective of our current timeline---in particular, it is perfectly fine to take a description of a staged computation that produces results from the second stage onwards and make it produce the results right from the first stage instead, which is what $\mathsf{force}$ does.

%It follows that a path between two inhabitants $\mathtt{next}\,x_i$ in a time step gives rise to a path now.
%In other words, paths are timeless.
%\begin{proposition}\label{lem:later-identity}
%  Let $x$ and $y$ be inhabitants of $A$. Then, $\forall \kappa.\, \left(\mathtt{next}\,\kappa\,x_1 = \mathtt{next}\,\kappa\,x_2\right)$ implies $x_1 = x_2$.
%\end{proposition}
%Be aware of the scope of clock quantification.
%The above proposition cannot hold within the same clock, that is, $\forall \kappa.\, \left(\mathtt{next}\,\kappa\,x_1 = \mathtt{next}\,\kappa\,x_2 \to x_1 =x_2\right)$ is not provable, since intuitively it would require us to retrieve inhabitants available later \emph{right now}.

\subsection{An exposure for the \texorpdfstring{\GL}{GL} modality}\label{sec:GL}

First we adapt the definition of exposures to the setting of CCTT.
\begin{definition}[Clocked exposure]
  Given $\PP$-categories $\mathbf{C}$ and $\mathbf{D}$, a \emph{clocked exposure} $Q\colon \mathbf{C} \looparrowright \mathbf{D}$ consists of \emph{(a)} a mapping $Q^\kappa$ for each clock~$\kappa$ from objects $X$ of~$\mathbf{C}$ to objects~$Q^\kappa X$ of $\mathbf{D}$ and \emph{(b)} for each clock~$\kappa$ from well-defined morphisms $f\colon X \to Y$ to well-defined morphisms $Q^\kappa f\colon Q^\kappa X \to Q^\kappa Y$ satisfying following properties
  \begin{romanenumerate}
    \item $Q^\kappa \iid_X \sim \iid_{QX}$,
    \item $Q^\kappa (g \circ f) \sim Q^\kappa g \circ Q^\kappa f$, and
    \item $f \sim g$ whenever $\forall\kappa.\, Q^\kappa f \sim Q^\kappa g$ for any two well-defined morphisms $f, g\colon X \to Y$. 
  \end{romanenumerate}
\end{definition}
Notably, the faithfulness of a clocked exposure mirrors the form of \Cref{lem:later-identity}, and is the main reason that we need CCTT.
%\Cref{thm:GL-exposure} gives an example of clocked exposure.

Now we introduce the clocked exposure $\Box \colon \Asm(\Lambda) \to \Asm(\Lambda)$ modelling \GL.
For an assembly $X$, the carrier $\bproj{\Box^\kappa X}$ and the realisability relation $\Vdash_{\Box^\kappa X}$ are defined as
\[
  \bproj{\Box^\kappa X} \defeq \sm{M : \Lambda_0}{x : {\laterp^\kappa \bproj{X}}} \laterp (\alpha : \kappa) .\, M \Vdash_X x [\alpha]
  \quad\text{and}\quad
  \left(N \Vdash_{\Box^\kappa X} (M, x, r) \right) \defeq N \reduce \qquote{M}
\]
where $\Vdash_{\Box^\kappa X}$ is defined in the same way as the exposure~$\boxtimes$.
The main difference between the carriers $\bproj{\boxtimes X}$ and $\bproj{\Box^\kappa X}$ is that the extension part $\bproj{X}$ becomes $\laterp^\kappa \bproj{X}$.
That is, the extension $x$ is available in a next stage but not earlier (with respect to the clock~$\kappa$), but the intension $M$ remains the same type.
Similarly, $\Box^\kappa X \defeq (\bproj{\Box^\kappa X}, \Vdash_{\Box^\kappa X}, r_{\Box^\kappa X}, t_{\Box^\kappa X})$ is an assembly where $r_{\Box^\kappa X}$ and $t_{\Box^\kappa X}$ are given by the transitivity and the reflexivity of $\reduce$. 

%\begin{notation*}
%  To avoid clumsy notations, the superscript of $\Box^\kappa$ is suppressed when appropriate.
%\end{notation*}

For any trackable map $f$ from $X$ to $Y$, also define $\Box^\kappa f$ in the same way as $\boxtimes f$ except that a later modality is involved: 
\[
  \bproj{\Box^\kappa f}(M, x, r) \defeq (F[M], \laterp^\kappa \bproj{f}\, x, \lam{\alpha}\mathfrak{f}\,M\,(x[\alpha])\,(r[\alpha]))
\]
where $\laterp^\kappa \bproj{f} : \laterp^\kappa \bproj{X} \to \laterp^\kappa \bproj{Y}$ is given by the functoriality of the later modality~$\mathord{\laterp}^\kappa$.
%with $(\laterp^\kappa \bproj{f}\, x)[\alpha]$ being judgementally equal to $|f|(x[\alpha])$.
The very same argument for $\boxtimes f$ shows that $\Box^\kappa f$ is indeed a trackable map from $\bproj{\Box^\kappa X}$ to $\bproj{\Box^\kappa Y}$.

\begin{remark*}
  By \Cref{lem:later-sum}, the carrier of $\Box^\kappa X$ and the type $\sm{M : \Lambda_0}\laterp^\kappa\, \sm{x : \bproj{X}} M \Vdash_X x$ are interchangeable.
  The latter form is more convenient when using guarded recursion.
\end{remark*}

It is straightforward to show that $\Box$~is a clocked exposure by \Cref{lem:later-identity}.
\begin{theorem}\label{thm:GL-exposure}
  $\Box \colon \Asm(\Lambda) \looparrowright \Asm(\Lambda)$ is a clocked exposure.
\end{theorem}

\begin{proposition}
There is a family of trackable maps
from $\Box^\kappa (X \Rightarrow Y)$ to $\Box^\kappa X \Rightarrow \Box^\kappa Y$  tracked by $\lam{\mathtt{x}_0} \mathtt{ap}[\mathtt{x}_1] \, \mathtt{x}_0$.
\end{proposition}

Similar to~\Cref{thm:S4-no-quoting}, no morphism $\Lambda_0 \to \Box^\kappa \Lambda_0$ can be quoting.
\begin{theorem}\label{thm:GL-no-quoting}
  There is no trackable map from $\Lambda_0$ to~$\Box^\kappa \Lambda_0$ which quotes closed elements.
\end{theorem}

It is also not possible to have a family of trackable maps $\epsilon_X$ from $\Box^\kappa X$ to $X$ natural in $X$, since the extension of $(M, x, r)$ can only be projected in a time step away from now.%
\begin{theorem}\label{thm:GL-no-eval}
  There is no function from $\bproj{\Box^\kappa \bot}$ to $\bproj{\bot}$.
  In particular, there is no natural transformation from $\Box^\kappa$ to $\mathcal{I}$ for any $\kappa$.
\end{theorem}
\begin{proof}
  Assume $\epsilon_\bot \colon \bproj{\Box^\kappa \bot} \to \bproj{\bot}$ exists. 
  We show that there is $\mathsf{bang}\colon \laterp \Empty \to \Empty$, so by guarded recursion a contradiction $\mathsf{fix}\,\mathsf{bang} : \Empty$ is derivable.
  Let $x$~be an inhabitant of $\laterp \Empty$. We construct an inhabitant $(M, x, r)$ of $\Box^\kappa \bot$
%  \[
%    \Box^\kappa \bot \equiv \sm{M : \Lambda_0}{x : {\laterp \Empty}} \laterp (\alpha : \kappa) .\, M \Vdash_\bot x [\alpha]
%  \]
  so that the function $\bproj{\epsilon_\bot}$ from $\bproj{\Box^\kappa \bot}$ to $\bproj{\bot} \equiv \Empty$ can be applied.
  Choose an arbitrary closed term~$M$, say $\mathtt{\lam{x}x}$, and apply the recursion principle~$\mathsf{rec}_{\Empty}$ of the empty type to~$x$ in a time step to get $r \defeq \lam{\alpha}\rec{\Empty}\,(M \Vdash_\bot x[\alpha])\,x[\alpha]$, which is an inhabitant of $\laterp (\alpha : \kappa) .\, M \Vdash_\bot x [\alpha]$, so $(M, x, r)$ is of type $\bproj{\Box^\kappa \bot}$. 
\end{proof}

The pay-off for disallowing evaluation is to be able to derive intensional recursion, which is logically the \GL axiom and its deductive form(s).

\begin{theorem}[Intensional recursion]\label{thm:GL-recursion}
  For every trackable map $f \colon \Box^\kappa X \to X$, there are
  \begin{enumerate}
    \item an element~$f^\dagger$ of $\Box^\kappa X$ realised by $\qquote{\mathsf{fix}\,F}$ and
    \item an element~$f^\ddagger$ of $X$ realised by~$\mathsf{fix}\,F$ satisfying $f^\ddagger \sim f \circ \Box^\kappa f^\ddagger \circ \bigstar$
  \end{enumerate}
  where $\mathsf{fix}\,F : \Lambda_0$ is a term that can be reduced to $F[\,\qquote{\mathsf{fix}\,F}\,]$.
\end{theorem}

\begin{proof}
  Let $f$~be a trackable map from $\Box^\kappa X$ to $X$ tracked by~$F : \Lambda_1$.
  Applying \Cref{thm:SRT} to $\lam{\mathtt{x}_0}F : \Lambda_0$, we obtain a term $\mathsf{fix}\,F : \Lambda_0$ with $\mathsf{fix}\,F \reduce (\lam{\mathtt{x}_0}F)\,\qquote{\mathsf{fix}\,F} \onereduce F[\,\qquote{\mathsf{fix}\,F}\,]$.
  Now we construct the first element by Löb induction on a $\Sigma$-type (\Cref{coro:lob-induction-sum}):
  assuming%
  \[
    x : \laterp \bproj{X}
    \quad\text{and}\quad
    r : \laterp (\alpha : \kappa).\, F[\,\qquote{\mathsf{fix}\,F}\,] \Vdash x [\alpha]
  \]
  we show an inhabitant of type $\bproj{X}$ realised by $\qquote{\mathsf{fix}\,F}$ as follows.
  \begin{enumerate}
    \item First,
      $\laterp(\alpha : \kappa).\left( \mathsf{fix}\,F \Vdash x [\alpha]\right)$ has an inhabitant, say $r'$, since $\mathsf{fix}\,F$ reduces to $F[\,\qquote{\mathsf{fix}\,F}\,]$. 
    \item Then, we derive an inhabitant of type $\bproj{X}$ realised by~$F[\,\qquote{\mathsf{fix}\,F}\,]$ as witnessed by%
      \[
        \mathfrak{f} (\refl_{\twoheadrightarrow}\qquote{\mathsf{fix}\,F}) : F[\,\qquote{\mathsf{fix}\,F}\,] \Vdash \bproj{f}(\mathsf{fix}\,F, x, r')
      \]
    since $F$ tracks $\bproj{f}$ and the set $\qquote{\mathsf{fix}\,F} \Vdash_{\Box^\kappa X} (\mathsf{fix}\,F, x, r')$ is judgementally equal to $\qquote{\mathsf{fix}\,F} \reduce \qquote{\mathsf{fix}\,F}$, which is inhabited by~$\refl_\twoheadrightarrow$.

    \item By Löb induction, $\sm{x : \laterp \bproj{X}} \laterp (\alpha : \kappa).\, F[\,\qquote{\mathsf{fix}\,F}\,] \Vdash x [\alpha]$ has an inhabitant~$(x_0, r_0)$.
    \item By $\mathsf{fix}\,F \reduce F[\,\qquote{\mathsf{fix}\,F}\,]$, we have 
      $(\mathsf{fix}\,F, x_0, r_0') : \bproj{\Box^\kappa X}$ where $r_0' : \laterp(\alpha : \kappa).\, \mathsf{fix}\,F \Vdash x_0 [\alpha]$.
  \end{enumerate}%
  Clearly $(\mathsf{fix}\,F, x_0, r_0')$ is realised by $\qquote{\mathsf{fix}\,F}$, and by \Cref{lem:global-element} it gives an element~$f^\dagger$ of $\Box X$.

  To construct the second element~$f^\ddagger$, we follow the same steps except the third: we conclude $(x_0, r_0) : \sm{x : \bproj{X}} F[\,\qquote{\mathsf{fix}\,F}\,] \Vdash x [\alpha]$ without any delay and thus $x_0 : \bproj{X}$ is realised by $r_0' : \mathsf{fix}\,F \Vdash x_0$.
  The equation $f^\ddagger \sim f\circ \Box^\kappa(f^\ddagger) \circ \bigstar$ follows from the fixed point equation for guarded recursion. 
\end{proof}
From the above proof, we can see that the intensional information available in the trackable map~$\Box^\kappa X \to X$, i.e.\ the tracker~$F$, does matter, since it is essential for constructing the fixpoint~$\mathsf{fix}\,F$. 
To internalise the inductive form as the \GL axiom, we also need the intension:%
\begin{theorem}\label{thm:internal-gl}
  There is a family of trackable maps from 
  $\Box^\kappa (\Box^\kappa X \Rightarrow X)$ to $\Box^\kappa X$.
\end{theorem}
The reader may wonder whether the strong Löb axiom, interpreted as a map from $\Box^\kappa X \Rightarrow X$ to~$X$, can also be realised by the SRT in a similar way, but from $\Box^\kappa X \Rightarrow X$, which amounts to a merely trackable map, we do not get the tracker~$F$ explicitly needed by the SRT.

\section{Related work}\label{sec:related-work}
Kavvos introduced a comonadic exposure~\cite[Theorem~11]{Kavvos2017b}, which we denote by~$\boxtimes_K$ here, on $\PP$-category of assemblies on a PCA (instead of $\lambda$-calculus) to model the intensional \SFour modality.
For an assembly $X$ on a PCA~$(A, \cdot)$, the assembly $\boxtimes_K X$ is defined by%
\[
\bproj{\boxtimes_K X} \defeq \{\,(a, x) \mid a \Vdash x \,\}
\quad\text{and}\quad
b \Vdash_{\boxtimes_K X} (a, x) \defeq a = b,
\]
without the use of Gödel encoding.
The morphism mapping is similar to~$\boxtimes$.
The difference between $\boxtimes_K$ and $\boxtimes$ mainly comes from the chosen notion of realisability and the use of Gödel encoding.
First, the exposure $\boxtimes_K$ preserves finite products, while $\boxtimes$ does not.
Some $\beta$-equivalent intensions have to be identified to satisfy equations of PCA.
For example
$\star : \bproj{\top}$ has only one realiser~$\mathtt{I}$, so $\bproj{\boxtimes_K \top}$ has only one element $(\star, \mathtt{I})$, too. 
Second, $\boxtimes_K$ is comonadic by a similar reason, while our $\delta$ is not even natural.
Third, $\boxtimes_K$ is idempotent, i.e.\ $\delta_K$ are isomorphisms, which is impossible for $\boxtimes$ because of Gödel encoding.
Finally, a generic quoting for~$\boxtimes_K$ \emph{can} be defined:
\begin{observation}
  For the one-element PCA, there exists a natural transformation from the identity exposure to~$\boxtimes_K$.
\end{observation}
Further, assuming the axiom of choice, there is (merely) a function~$q$ from $ \bproj{X}$ to $\bproj{\boxtimes_K X}$ because of the right totality of~$\Vdash$.
It is likely that~$q$ could be realised in the sense of Krivine's classical realisability~\cite{Krivine2021}, which would establish a non-trivial example of generic quoting for~$\boxtimes_K$ or alike.
On the other hand, using $\lambda$-terms subject to $\alpha$-equivalence as realisers and $\qquote{M}$ as realisers for $(M, x, r)$ allows the exposure~$\boxtimes$ to distinguish $\beta$-equivalent intensions, so $\boxtimes$---being more intensional than~$\boxtimes_K$---lacks well-behaved extensional properties, as expected.


As a reviewer pointed out, \cref{re:naturality} is reminiscent of \emph{categorical simulation} studied by Cockett and Hofstra~\cite{Cockett2010}.

Artemov and Beklemishev~\cite{Artemov2005} pointed out that
Gödel attempted to use classical \SFour modal logic to capture provability for Peano Arithmetic ($\mathbf{PA}$) but realised that $\mathsf{Prov}(A) \defeq \exists x.\, \mathsf{Proof}(x, A)$ cannot be \SFour.
Löb found the well-known \GL axiom and
Solovay showed that \GL is complete with respect to~$\mathbf{PA}$.
On the other hand, Artemov~\cite{Artemov2001} proposed \emph{logic of proofs} extending \SFour and argued that \SFour is for \emph{explicit proofs}.
Goris~\cite{Goris2009} discussed two modalities \GL and \SFour over classical logic by presenting a bi-modal logic and provides a Kripke semantics for both.
We took Goris' notation for the \SFour modality $\boxtimes$.
Our work is partly inspired by Shamkanov's~\cite{Shamkanov2014, Shamkanov2016a} provability semantics for \GL using circular proofs.

\section{Conclusion}\label{sec:conclusion}
In this paper we follow the principle of modality-as-intension~\cite{Davies2001b} and the $\PP$-categorical semantics~\cite{Kavvos2017b} to manifest the concepts of denotations, extensions, and intensions.
We have studied the $\PP$-category of assemblies on $\lambda$-calculus developed and formalised in HoTT as a semantic foundation for intensionality, on which we modelled \SFour and \GL modalities.
Notably, our denotational semantics of the \SFour modality~$\boxtimes$ is more intensional than that of Kavvos' $\boxtimes_K$.
For the \GL modality~$\Box$, we have given the \emph{first} denotational semantics, which is shown~(\Cref{thm:GL-recursion} and \Cref{thm:internal-gl}) to satisfy the Gödel-Löb axiom and its deductive form---the intensional recursion---using guarded type theory.

As future work, an important issue we have not discussed yet is the connection between $\boxtimes$~and~$\Box$---for example, it is easy to construct a family of trackable maps from $\boxtimes X$ to $\Box^\kappa X$ natural in $X$ by deferring the extension part of $(M, x)$ to a later stage, and Goris' bi-modal logic~\cite{Goris2009} suggests that there are more rules to discover.
In the long term, based on the $\PP$-category of assemblies and the denotational semantics of modalities, we intend to design a type theory with two modes of $\mathtt{Code}$ and prove its meta-properties such as consistency, confluence, and decidability of type checking by interpreting judgements into~$\Asm(\Lambda)$.

%\paragraph*{Future work}
%First, as we have two apparently related exposures, one immediate question is how these two exposures are connected.  There is clearly a natural transformation from $\boxtimes$ to $\Box$ deferring computation to the next stage, but we do not know else much.
%The classical \SFour and \GL modalities and their connection laws are studied in Hilbert-style logic by Goris~\cite{Goris2009} with Kripke semantics in the context of provability logic.
%Accordingly, we would like to describe a type theory enriched with modalities $\boxtimes$ and $\Box$ unifying modal type theories considered by Davies and Pfenning~\cite{Davies2001b}, Pfenning~\cite{Pfenning2002a}, and by Kavvos~\cite{Kavvos2017b,Kavvos2020} while maintaining consistency.
%
%Second, inhabitants of $\Box^\kappa X$ are not accessible until the next stage. In order to arrive the next stage one needs a way to $\mathtt{force}$ them. 
%This suggests a new language construct for $\Box^\kappa X$ apart from its introduction and elimination rules considered by Kavvos~\cite{Kavvos2021}.
%This construct may correspond to compiler-time code generation---a common form of metaprogramming during compiler-time which, to be the best of our knowledge, does not have a known denotational semantics.

%\ltnote{Third, \Cref{re:boxtimes-is-not} suggests a theory on categories enriched by \emph{partially ordered $\PP$-sets} instead}

%Finally, categories internal to clocked type theory seem worth further investigation.
%It is a natural setting when the underlying foundation is equipped with Löb induction (guarded recursion) as an abstract approach to the step-indexing technique used to reason about programming language features.
%We expect this line of research may provide a convenient framework for categorical semantics of those programming languages.
%

%If we follow the insight of Davies and Pfenning, then $\boxtimes X$ should be understood as the denotation for the type of typed code.
%As a sanity check, we may further ask the type $\mathsf{Code}$ of \emph{untyped} code and a polymorphic function from $\boxtimes A$ to $\mathsf{Code}$ forgetting what a typed code denotes. 
%This is indeed the case and the point of the following statement.
%\begin{theorem}
%
%  
%\end{theorem}

\nocite{Bauer2006}
\bibliographystyle{plainurl}% the mandatory bibstyle
\bibliography{ref}

\appendix

\end{document}
